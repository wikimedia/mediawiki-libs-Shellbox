<?php
/*
 * Generated by WikiPEG
 */


namespace Shellbox\ShellParser;


	use Wikimedia\WikiPEG\InternalError;



class PEGParserCacheEntry {
	public $nextPos;
	public $result;


	public function __construct( $nextPos, $result ) {
		$this->nextPos = $nextPos;
		$this->result = $result;

	}
}


class PEGParser extends \Wikimedia\WikiPEG\PEGParserBase {
	// initializer
	
	/**
	 * Overridable tree node constructor
	 *
	 * @stable to override
	 * @param string $type
	 * @param array|Node|string $contents
	 * @return Node
	 */
	protected function node( $type, $contents ) {
		return new Node( $type, $contents );
	}

	/**
	 * Combine arrays and non-array items into a single flat array.
	 *
	 * @param array|Node|string|null ...$items
	 * @return array
	 * @phan-return array<Node|string>
	 */
	private function merge( ...$items ) {
		if ( !$items ) {
			return [];
		}
		$mergeArgs = [];
		foreach ( $items as $item ) {
			if ( $item !== null ) {
				if ( !is_array( $item ) ) {
					$mergeArgs[] = [ $item ];
				} else {
					$mergeArgs[] = $item;
				}
			}
		}
		return array_merge( ...$mergeArgs );
	}


	// cache init
	  protected $cache = [];

	// expectations
	protected $expectations = [
		0 => ["type" => "end", "description" => "end of input"],
1 => ["type" => "other", "description" => "complete_command"],
2 => ["type" => "other", "description" => "newline_list"],
3 => ["type" => "other", "description" => "and_or"],
4 => ["type" => "other", "description" => "separator_op"],
5 => ["type" => "other", "description" => "pipeline"],
6 => ["type" => "other", "description" => "AND_IF"],
7 => ["type" => "other", "description" => "OR_IF"],
8 => ["type" => "other", "description" => "Bang"],
9 => ["type" => "other", "description" => "pipe_sequence"],
10 => ["type" => "literal", "value" => "!", "description" => "\"!\""],
11 => ["type" => "other", "description" => "command"],
12 => ["type" => "other", "description" => "PIPE"],
13 => ["type" => "class", "value" => "[ \\t\\v\\r\\f]", "description" => "[ \\t\\v\\r\\f]"],
14 => ["type" => "other", "description" => "function_definition"],
15 => ["type" => "other", "description" => "simple_command"],
16 => ["type" => "other", "description" => "compound_command"],
17 => ["type" => "other", "description" => "redirect_list"],
18 => ["type" => "other", "description" => "NAME"],
19 => ["type" => "other", "description" => "LPAREN"],
20 => ["type" => "other", "description" => "RPAREN"],
21 => ["type" => "other", "description" => "function_body"],
22 => ["type" => "other", "description" => "cmd_prefix"],
23 => ["type" => "other", "description" => "WORD"],
24 => ["type" => "other", "description" => "cmd_suffix"],
25 => ["type" => "other", "description" => "cmd_name"],
26 => ["type" => "other", "description" => "brace_group"],
27 => ["type" => "other", "description" => "subshell"],
28 => ["type" => "other", "description" => "for_clause"],
29 => ["type" => "other", "description" => "case_clause"],
30 => ["type" => "other", "description" => "if_clause"],
31 => ["type" => "other", "description" => "while_clause"],
32 => ["type" => "other", "description" => "until_clause"],
33 => ["type" => "other", "description" => "io_redirect"],
34 => ["type" => "class", "value" => "[_a-zA-Z]", "description" => "[_a-zA-Z]"],
35 => ["type" => "class", "value" => "[_a-zA-Z0-9]", "description" => "[_a-zA-Z0-9]"],
36 => ["type" => "other", "description" => "ASSIGNMENT_WORD"],
37 => ["type" => "other", "description" => "word_part"],
38 => ["type" => "other", "description" => "Lbrace"],
39 => ["type" => "other", "description" => "compound_list"],
40 => ["type" => "other", "description" => "Rbrace"],
41 => ["type" => "other", "description" => "For"],
42 => ["type" => "other", "description" => "for_name"],
43 => ["type" => "other", "description" => "for_case_in"],
44 => ["type" => "other", "description" => "wordlist"],
45 => ["type" => "other", "description" => "sequential_sep"],
46 => ["type" => "other", "description" => "do_group"],
47 => ["type" => "other", "description" => "Case"],
48 => ["type" => "other", "description" => "case_list"],
49 => ["type" => "other", "description" => "Esac"],
50 => ["type" => "other", "description" => "case_list_ns"],
51 => ["type" => "other", "description" => "If"],
52 => ["type" => "other", "description" => "Then"],
53 => ["type" => "other", "description" => "else_part"],
54 => ["type" => "other", "description" => "Fi"],
55 => ["type" => "other", "description" => "While"],
56 => ["type" => "other", "description" => "Until"],
57 => ["type" => "class", "value" => "[0-9]", "description" => "[0-9]"],
58 => ["type" => "other", "description" => "io_file"],
59 => ["type" => "other", "description" => "io_here"],
60 => ["type" => "literal", "value" => "=", "description" => "\"=\""],
61 => ["type" => "other", "description" => "single_quoted_part"],
62 => ["type" => "other", "description" => "double_quoted_part"],
63 => ["type" => "other", "description" => "bare_escape_sequence"],
64 => ["type" => "other", "description" => "backquote_expansion"],
65 => ["type" => "other", "description" => "dollar_expansion"],
66 => ["type" => "other", "description" => "plain_part"],
67 => ["type" => "other", "description" => "separator"],
68 => ["type" => "other", "description" => "Do"],
69 => ["type" => "other", "description" => "Done"],
70 => ["type" => "other", "description" => "case_item"],
71 => ["type" => "other", "description" => "case_item_ns"],
72 => ["type" => "other", "description" => "Elif"],
73 => ["type" => "other", "description" => "Else"],
74 => ["type" => "other", "description" => "LESSAND"],
75 => ["type" => "other", "description" => "LESSGREAT"],
76 => ["type" => "other", "description" => "LESS"],
77 => ["type" => "other", "description" => "GREATAND"],
78 => ["type" => "other", "description" => "DGREAT"],
79 => ["type" => "other", "description" => "CLOBBER"],
80 => ["type" => "other", "description" => "GREAT"],
81 => ["type" => "other", "description" => "DLESSDASH"],
82 => ["type" => "other", "description" => "DLESS"],
83 => ["type" => "other", "description" => "here_end"],
84 => ["type" => "literal", "value" => "'", "description" => "\"'\""],
85 => ["type" => "class", "value" => "[^']", "description" => "[^']"],
86 => ["type" => "literal", "value" => "\"", "description" => "\"\\\"\""],
87 => ["type" => "other", "description" => "dquoted_escape"],
88 => ["type" => "literal", "value" => "\\", "description" => "\"\\\\\""],
89 => ["type" => "class", "value" => "[^\"`\$\\\\]", "description" => "[^\"`\$\\\\]"],
90 => ["type" => "class", "value" => "[^\\n]", "description" => "[^\\n]"],
91 => ["type" => "literal", "value" => "`", "description" => "\"`\""],
92 => ["type" => "other", "description" => "backquoted_escape"],
93 => ["type" => "other", "description" => "double_backquote_expansion"],
94 => ["type" => "literal", "value" => "\$", "description" => "\"\$\""],
95 => ["type" => "class", "value" => "[^`\$\\\\]", "description" => "[^`\$\\\\]"],
96 => ["type" => "other", "description" => "special_parameter"],
97 => ["type" => "other", "description" => "short_positional_parameter"],
98 => ["type" => "other", "description" => "brace_expansion"],
99 => ["type" => "other", "description" => "arithmetic_expansion"],
100 => ["type" => "other", "description" => "command_expansion"],
101 => ["type" => "other", "description" => "named_parameter"],
102 => ["type" => "class", "value" => "[^'\"\\\\`\$ \\t\\v\\r\\f\\n&|;<>(){}]", "description" => "[^'\"\\\\`\$ \\t\\v\\r\\f\\n&|;<>(){}]"],
103 => ["type" => "class", "value" => "[^'\"\\\\`\$ \\t\\v\\r\\f\\n&|;<>()]", "description" => "[^'\"\\\\`\$ \\t\\v\\r\\f\\n&|;<>()]"],
104 => ["type" => "other", "description" => "pattern"],
105 => ["type" => "other", "description" => "DSEMI"],
106 => ["type" => "class", "value" => "[\$`\"\\\\\\n]", "description" => "[\$`\"\\\\\\n]"],
107 => ["type" => "class", "value" => "[\$\\\\]", "description" => "[\$\\\\]"],
108 => ["type" => "literal", "value" => "\\`", "description" => "\"\\\\`\""],
109 => ["type" => "class", "value" => "[@*#?\\-\$!0]", "description" => "[@*#?\\-\$!0]"],
110 => ["type" => "class", "value" => "[1-9]", "description" => "[1-9]"],
111 => ["type" => "literal", "value" => "{", "description" => "\"{\""],
112 => ["type" => "other", "description" => "binary_expansion"],
113 => ["type" => "other", "description" => "string_length"],
114 => ["type" => "other", "description" => "braced_parameter_expansion"],
115 => ["type" => "literal", "value" => "}", "description" => "\"}\""],
116 => ["type" => "literal", "value" => "((", "description" => "\"((\""],
117 => ["type" => "literal", "value" => "))", "description" => "\"))\""],
118 => ["type" => "literal", "value" => "(", "description" => "\"(\""],
119 => ["type" => "literal", "value" => ")", "description" => "\")\""],
120 => ["type" => "other", "description" => "parameter"],
121 => ["type" => "literal", "value" => ":", "description" => "\":\""],
122 => ["type" => "class", "value" => "[\\-=?+]", "description" => "[\\-=?+]"],
123 => ["type" => "literal", "value" => "%%", "description" => "\"%%\""],
124 => ["type" => "literal", "value" => "##", "description" => "\"##\""],
125 => ["type" => "class", "value" => "[%#\\-=?+]", "description" => "[%#\\-=?+]"],
126 => ["type" => "literal", "value" => "#", "description" => "\"#\""],
127 => ["type" => "literal", "value" => "|", "description" => "\"|\""],
128 => ["type" => "other", "description" => "long_positional_parameter"],
	];

	// actions
	private function a0($commands) {

		return $this->node( 'program', $commands );
	
}
private function a1($c) {

			return $c;
		
}
private function a2($item, $separator) {

				if ( $separator && $separator[0] === '&' ) {
					return $this->node( 'background', $item );
				} else {
					return $item;
				}
			
}
private function a3($nodes, $last) {

			if ( $last ) {
                $nodes[] = $last;
            }
            if ( count( $nodes ) > 1 ) {
                return $this->node( 'list', $nodes );
            } else {
                return $nodes[0];
            }
		
}
private function a4($list) {

	return $this->node( 'complete_command', $list );

}
private function a5($first, $pipeline) {

			return $this->node( 'and_if', $pipeline );
		
}
private function a6($first, $pipeline) {

			return $this->node( 'or_if', $pipeline );
		
}
private function a7($first, $rest) {

	return $this->merge( $first, $rest );

}
private function a8($bang, $pipeline) {

	if ( $bang !== null ) {
		return $this->node( 'bang', $pipeline );
	} else {
		return $pipeline;
	}

}
private function a9($first, $command) {

			return $command;
		
}
private function a10($first, $rest) {

	if ( count( $rest ) ) {
		return $this->node( 'pipeline', $this->merge( $first, $rest ) );
	} else {
		return $first;
	}

}
private function a11($c, $r) {

		if ( $r !== null ) {
			return $this->merge( $c, $r );
		} else {
			return $c;
		}
	
}
private function a12($fname, $body) {

	return $this->node( 'function_definition',
		$this->merge( $this->node( 'function_name', $fname ), $body ) );

}
private function a13($prefix, $word, $suffix) {

		$contents = [ $prefix, $word ];
		if ( $suffix !== null ) {
			$contents = array_merge( $contents, $suffix );
		}
		return $this->node( 'simple_command', $contents );
	
}
private function a14($prefix) {

		return $this->node( 'simple_command', [ $prefix ] );
	
}
private function a15($name, $suffix) {

		$contents = [ $name ];
		if ( $suffix ) {
			$contents = array_merge( $contents, $suffix );
		}
		return $this->node( 'simple_command', $contents );
	
}
private function a16($c, $r) {

	if ( $r !== null ) {
		return $this->merge( $c, $r );
	} else {
		return $c;
	}

}
private function a17($contents) {

	return $this->node( 'cmd_prefix', $contents );

}
private function a18($parts) {

	return $this->node( 'word', $parts );

}
private function a19($word) {

	return $word;

}
private function a20($list) {

	return $this->node( 'brace_group', $list );

}
private function a21($list) {

	return $this->node( 'subshell', $list );

}
private function a22($name, $wordlist, $do_group) {

			return $this->node( 'for', [ $name, $this->node( 'in', $wordlist ?: [] ), $do_group ] );
		
}
private function a23($name, $do_group) {

			return $this->node( 'for', [ $name, $do_group ] );
		
}
private function a24($word, $list_esac) {

	if ( is_array( $list_esac ) ) {
		$list = $list_esac[0];
	} else {
		$list = [];
	}
	return $this->node( 'case', [ $word, $this->node( 'in', $list ) ] );

}
private function a25($condition, $consequent, $else_part) {

	$contents = [
		$this->node( 'condition', $condition ),
		$this->node( 'consequent', $consequent )
	];
	if ( $else_part !== null ) {
		$contents = $this->merge( $contents, $else_part );
	}
	return $this->node( 'if', $contents );

}
private function a26($list, $body) {

	return $this->node( 'while', [
		$this->node( 'condition', $list ),
		$body
	] );

}
private function a27($list, $body) {

	return $this->node( 'until', [
		$this->node( 'condition', $list ),
		$body
	] );

}
private function a28($number, $file_or_here) {

		$contents = [];
		if ( $number !== null ) {
			$contents[] = $this->node( 'io_subject', $number );
		}
		$contents[] = $file_or_here;
		return $this->node( 'io_redirect', $contents );
	
}
private function a29($name, $word) {

	return $this->node( 'assignment', [ $this->node( 'name', $name ), $word ] );

}
private function a30($term, $separator) {

			if ( $separator && $separator[0] === '&' ) {
				return $this->node( 'background', $term );
			} else {
				return $term;
			}
		
}
private function a31($terms, $last) {

		if ( $last ) {
			$terms[] = $last;
		}
		return $terms;
	
}
private function a32($term) {

		if ( $term === null ) {
			// Phan is convinced $term may be null, not sure how
			return [];
		} else {
			return $term;
		}
	
}
private function a33($name) {

	return $name;

}
private function a34($list) {

	return $this->node( 'do', $list );

}
private function a35($list, $item) {

		$list[] = $item;
		return $list;
	
}
private function a36($item) {

		return [ $item ];
	
}
private function a37($condition, $consequent, $else_part) {

		$contents = [
			$this->node( 'elif_condition', $condition ),
			$this->node( 'elif_consequent', $consequent )
		];
		if ( $else_part !== null ) {
			$contents = $this->merge( $contents, $else_part );
		}
		return $contents;
	
}
private function a38($alternative) {

		return [ $this->node( 'else', $alternative ) ];
	
}
private function a39($filename) {

		return $this->node( 'duplicate_input', $filename );
	
}
private function a40($filename) {

		return $this->node( 'read_and_write', $filename );
	
}
private function a41($filename) {

		return $this->node( 'input', $filename );
	
}
private function a42($filename) {

		return $this->node( 'duplicate_output', $filename );
	
}
private function a43($filename) {

		return $this->node( 'append_output', $filename );
	
}
private function a44($filename) {

		return $this->node( 'clobber', $filename );
	
}
private function a45($filename) {

		return $this->node( 'output', $filename );
	
}
private function a46() {
 return 'io_here_strip'; 
}
private function a47() {
 return 'io_here'; 
}
private function a48($op, $end) {
	// @phan-suppress-previous-line PhanPluginNeverReturnMethod
	// TODO: this is quite complicated to implement, especially given the way
	// the parser is structured.
	throw new UnimplementedError( 'heredoc is not implemented' );
	// For phan
	// @phan-suppress-next-line PhanPluginUnreachableCode
	return $this->node( 'io_here', '' );

}
private function a49($contents) {

	return $this->node( 'single_quote', $contents );

}
private function a50($contents) {

	return $this->node( 'double_quote', $contents );

}
private function a51($contents) {

	return $this->node( 'bare_escape', $contents );

}
private function a52($parts) {

	return $this->node( 'backquote', $parts );

}
private function a53($contents) {

	return $contents;

}
private function a54($plain) {

	return $this->node( 'unquoted_literal', $plain );

}
private function a55($pattern, $list) {

		return $this->node( 'case_item', [
			$pattern,
			$this->node( 'case_consequent', $list )
		] );
	
}
private function a56($pattern) {

		return $this->node( 'case_item', $pattern );
	
}
private function a57($pattern) {

		return $this->node( 'case_item', [ $pattern ] );
	
}
private function a58($contents) {

	return $this->node( 'dquoted_escape', $contents );

}
private function a59($contents) {

	return $this->node( 'backquoted_escape', $contents );

}
private function a60($parts) {

	return $this->node( 'double_backquote', $parts );

}
private function a61($contents) {

	return $this->node( 'special_parameter', $contents );

}
private function a62($contents) {

	return $this->node( 'positional_parameter', $contents );

}
private function a63($words) {

	return $this->node( 'arithmetic_expansion', $words );

}
private function a64($command) {

	return $this->node( 'command_expansion', $command );

}
private function a65($name) {

	return $this->node( 'named_parameter', $name );

}
private function a66($first, $rest) {

	$patterns = [ $first ];
	foreach ( $rest as $pattern ) {
		$patterns[] = $pattern[1];
	}
	return $this->node( 'case_pattern', $patterns );

}
private function a67($parameter, $operator, $word) {

	$names = [
		':-' => 'use_default',
		'-' => 'use_default_unset',
		':=' => 'assign_default',
		'=' => 'assign_default_unset',
		':?' => 'indicate_error',
		'?' => 'indicate_error_unset',
		':+' => 'use_alternative',
		'+' => 'use_alternative_unset',
		'%' => 'remove_smallest_suffix',
		'%%' => 'remove_largest_suffix',
		'#' => 'remove_smallest_prefix',
		'##' => 'remove_largest_prefix'
	];
	if ( !isset( $names[$operator] ) ) {
		throw new InternalError( "Unable to find operator \"$operator\"" );
	}
	return $this->node( $names[$operator], [ $parameter, $word ?? '' ] );

}
private function a68($parameter) {

	return $this->node( 'string_length', $parameter );

}
private function a69($parameter) {

	return $this->node( 'braced_parameter_expansion', $parameter );

}
private function a70($parameter) {

	return $this->node( 'positional_parameter', $parameter );

}

	// generated
	private function parseprogram($silence) {
  $key = json_encode([0,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $this->discardlinebreak();
  $r3 = $this->parsecomplete_commands($silence);
  // commands <- $r3
  $this->discardlinebreak();
  $r2 = true;
  seq_1:
  $this->savedPos = $p1;
  $r2 = $this->a0($r3);
  // free $p1
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardlinebreak() {
  $key = json_encode([77,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $r3 = $this->input[$this->currPos] ?? '';
  if ($r3 === "\x0a") {
    $r3 = false;
    $this->currPos = $p1;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = $this->discardnewline_list();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  if ($r2===self::$FAILED) {
    $r2 = null;
  }
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecomplete_commands($silence) {
  $key = json_encode([2,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $r2 = [];
  for (;;) {
    // start choice_1
    $p4 = $this->currPos;
    // start seq_1
    $p5 = $this->currPos;
    // start seq_2
    if (strcspn($this->input, "\x0a&);|", $this->currPos, 1) !== 0) {
      $r7 = true;
      $r7 = false;
      $this->currPos = $p5;
    } else {
      $r7 = self::$FAILED;
      if (!$silence) { $this->fail(1); }
      $r6 = self::$FAILED;
      goto seq_2;
    }
    $r6 = $this->parsecomplete_command($silence, 0x0);
    if ($r6===self::$FAILED) {
      $this->currPos = $p5;
      $r6 = self::$FAILED;
      goto seq_2;
    }
    seq_2:
    // c <- $r6
    if ($r6===self::$FAILED) {
      $r3 = self::$FAILED;
      goto seq_1;
    }
    // start seq_3
    $p9 = $this->currPos;
    $r10 = $this->input[$this->currPos] ?? '';
    if ($r10 === "\x0a") {
      $r10 = false;
      $this->currPos = $p9;
    } else {
      $r10 = self::$FAILED;
      if (!$silence) { $this->fail(2); }
      $r8 = self::$FAILED;
      goto seq_3;
    }
    $r8 = $this->discardnewline_list();
    if ($r8===self::$FAILED) {
      $this->currPos = $p9;
      $r8 = self::$FAILED;
      goto seq_3;
    }
    seq_3:
    if ($r8===self::$FAILED) {
      $this->currPos = $p5;
      $r3 = self::$FAILED;
      goto seq_1;
    }
    // free $p9
    $r3 = true;
    seq_1:
    if ($r3!==self::$FAILED) {
      $this->savedPos = $p4;
      $r3 = $this->a1($r6);
      goto choice_1;
    }
    // free $r7,$r8,$r10
    // free $p5
    // free $p4
    // start seq_4
    $p4 = $this->currPos;
    if (strcspn($this->input, "\x0a&);|", $this->currPos, 1) !== 0) {
      $r10 = true;
      $r10 = false;
      $this->currPos = $p4;
    } else {
      $r10 = self::$FAILED;
      if (!$silence) { $this->fail(1); }
      $r3 = self::$FAILED;
      goto seq_4;
    }
    $r3 = $this->parsecomplete_command($silence, 0x0);
    if ($r3===self::$FAILED) {
      $this->currPos = $p4;
      $r3 = self::$FAILED;
      goto seq_4;
    }
    seq_4:
    // free $p4
    choice_1:
    if ($r3!==self::$FAILED) {
      $r2[] = $r3;
    } else {
      break;
    }
  }
  // free $r3
  // free $r10
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardnewline_list() {
  $key = json_encode([75,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $r2 = self::$FAILED;
  for (;;) {
    // start seq_1
    $p4 = $this->currPos;
    $r5 = $this->input[$this->currPos] ?? '';
    if ($r5 === "\x0a") {
      $r5 = false;
      $this->currPos = $p4;
    } else {
      $r5 = self::$FAILED;
      $r3 = self::$FAILED;
      goto seq_1;
    }
    $r3 = $this->discardNEWLINE();
    if ($r3===self::$FAILED) {
      $this->currPos = $p4;
      $r3 = self::$FAILED;
      goto seq_1;
    }
    seq_1:
    if ($r3!==self::$FAILED) {
      $r2 = true;
    } else {
      break;
    }
    // free $p4
  }
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecomplete_command($silence, $boolParams) {
  $key = json_encode([4,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $this->discardOWS();
  // start choice_1
  $p4 = $this->currPos;
  // start seq_2
  $p5 = $this->currPos;
  $r6 = [];
  for (;;) {
    $p8 = $this->currPos;
    // start seq_3
    $p9 = $this->currPos;
    // start seq_4
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
      $r11 = true;
      $r11 = false;
      $this->currPos = $p9;
    } else {
      $r11 = self::$FAILED;
      if (!$silence) { $this->fail(3); }
      $r10 = self::$FAILED;
      goto seq_4;
    }
    $r10 = $this->parseand_or($silence, $boolParams);
    if ($r10===self::$FAILED) {
      $this->currPos = $p9;
      $r10 = self::$FAILED;
      goto seq_4;
    }
    seq_4:
    // item <- $r10
    if ($r10===self::$FAILED) {
      $r7 = self::$FAILED;
      goto seq_3;
    }
    $p13 = $this->currPos;
    // start seq_5
    $p14 = $this->currPos;
    $r15 = $this->input[$this->currPos] ?? '';
    if ($r15 === "&" || $r15 === ";") {
      $r15 = false;
      $this->currPos = $p14;
    } else {
      $r15 = self::$FAILED;
      if (!$silence) { $this->fail(4); }
      $r12 = self::$FAILED;
      goto seq_5;
    }
    $r12 = $this->discardseparator_op();
    if ($r12===self::$FAILED) {
      $this->currPos = $p14;
      $r12 = self::$FAILED;
      goto seq_5;
    }
    seq_5:
    // separator <- $r12
    if ($r12!==self::$FAILED) {
      $r12 = substr($this->input, $p13, $this->currPos - $p13);
    } else {
      $r12 = self::$FAILED;
      $this->currPos = $p9;
      $r7 = self::$FAILED;
      goto seq_3;
    }
    // free $p14
    // free $p13
    $r7 = true;
    seq_3:
    if ($r7!==self::$FAILED) {
      $this->savedPos = $p8;
      $r7 = $this->a2($r10, $r12);
      $r6[] = $r7;
    } else {
      break;
    }
    // free $r11,$r15
    // free $p9
    // free $p8
  }
  if (count($r6) === 0) {
    $r6 = self::$FAILED;
  }
  // nodes <- $r6
  if ($r6===self::$FAILED) {
    $r3 = self::$FAILED;
    goto seq_2;
  }
  // free $r7
  // start seq_6
  $p8 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r15 = true;
    $r15 = false;
    $this->currPos = $p8;
  } else {
    $r15 = self::$FAILED;
    if (!$silence) { $this->fail(3); }
    $r7 = self::$FAILED;
    goto seq_6;
  }
  $r7 = $this->parseand_or($silence, $boolParams);
  if ($r7===self::$FAILED) {
    $this->currPos = $p8;
    $r7 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r7===self::$FAILED) {
    $r7 = null;
  }
  // free $p8
  // last <- $r7
  $r3 = true;
  seq_2:
  if ($r3!==self::$FAILED) {
    $this->savedPos = $p4;
    $r3 = $this->a3($r6, $r7);
    goto choice_1;
  }
  // free $r15
  // free $p5
  // free $p4
  // start seq_7
  $p4 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r15 = true;
    $r15 = false;
    $this->currPos = $p4;
  } else {
    $r15 = self::$FAILED;
    if (!$silence) { $this->fail(3); }
    $r3 = self::$FAILED;
    goto seq_7;
  }
  $r3 = $this->parseand_or($silence, $boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p4;
    $r3 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  // free $p4
  choice_1:
  // list <- $r3
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a4($r3);
  }
  // free $r15
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardNEWLINE() {
  $key = json_encode([205,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "\x0a") {
    $r3 = true;
    $this->currPos++;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardOWS() {
  $key = json_encode([153,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $r3 = strspn($this->input, "\x09\x0b\x0c\x0d ", $this->currPos);
  $this->currPos += $r3;
  // start seq_2
  $p5 = $this->currPos;
  if (($this->input[$this->currPos] ?? null) === "#") {
    $r6 = true;
    $this->currPos++;
  } else {
    $r6 = self::$FAILED;
    $r4 = self::$FAILED;
    goto seq_2;
  }
  $r7 = strcspn($this->input, "\x0a", $this->currPos);
  $this->currPos += $r7;
  $r4 = true;
  seq_2:
  if ($r4===self::$FAILED) {
    $r4 = null;
  }
  // free $r6,$r7
  // free $p5
  $r2 = true;
  seq_1:
  // free $r3,$r4
  // free $p1
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseand_or($silence, $boolParams) {
  $key = json_encode([6,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(5); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parsepipeline($silence, $boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // first <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r5 = [];
  for (;;) {
    // start choice_1
    $p7 = $this->currPos;
    // start seq_3
    $p8 = $this->currPos;
    // start seq_4
    $r10 = $this->input[$this->currPos] ?? '';
    if ($r10 === "&") {
      $r10 = false;
      $this->currPos = $p8;
    } else {
      $r10 = self::$FAILED;
      if (!$silence) { $this->fail(6); }
      $r9 = self::$FAILED;
      goto seq_4;
    }
    $r9 = $this->discardAND_IF();
    if ($r9===self::$FAILED) {
      $this->currPos = $p8;
      $r9 = self::$FAILED;
      goto seq_4;
    }
    seq_4:
    if ($r9===self::$FAILED) {
      $r6 = self::$FAILED;
      goto seq_3;
    }
    $this->discardlinebreak();
    // start seq_5
    $p12 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
      $r13 = true;
      $r13 = false;
      $this->currPos = $p12;
    } else {
      $r13 = self::$FAILED;
      if (!$silence) { $this->fail(5); }
      $r11 = self::$FAILED;
      goto seq_5;
    }
    $r11 = $this->parsepipeline($silence, $boolParams);
    if ($r11===self::$FAILED) {
      $this->currPos = $p12;
      $r11 = self::$FAILED;
      goto seq_5;
    }
    seq_5:
    // pipeline <- $r11
    if ($r11===self::$FAILED) {
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_3;
    }
    // free $p12
    $r6 = true;
    seq_3:
    if ($r6!==self::$FAILED) {
      $this->savedPos = $p7;
      $r6 = $this->a5($r3, $r11);
      goto choice_1;
    }
    // free $r9,$r10,$r13
    // free $p8
    // free $p7
    $p7 = $this->currPos;
    // start seq_6
    $p8 = $this->currPos;
    // start seq_7
    $r10 = $this->input[$this->currPos] ?? '';
    if ($r10 === "|") {
      $r10 = false;
      $this->currPos = $p8;
    } else {
      $r10 = self::$FAILED;
      if (!$silence) { $this->fail(7); }
      $r13 = self::$FAILED;
      goto seq_7;
    }
    $r13 = $this->discardOR_IF();
    if ($r13===self::$FAILED) {
      $this->currPos = $p8;
      $r13 = self::$FAILED;
      goto seq_7;
    }
    seq_7:
    if ($r13===self::$FAILED) {
      $r6 = self::$FAILED;
      goto seq_6;
    }
    $this->discardlinebreak();
    // start seq_8
    $p12 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
      $r14 = true;
      $r14 = false;
      $this->currPos = $p12;
    } else {
      $r14 = self::$FAILED;
      if (!$silence) { $this->fail(5); }
      $r9 = self::$FAILED;
      goto seq_8;
    }
    $r9 = $this->parsepipeline($silence, $boolParams);
    if ($r9===self::$FAILED) {
      $this->currPos = $p12;
      $r9 = self::$FAILED;
      goto seq_8;
    }
    seq_8:
    // pipeline <- $r9
    if ($r9===self::$FAILED) {
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_6;
    }
    // free $p12
    $r6 = true;
    seq_6:
    if ($r6!==self::$FAILED) {
      $this->savedPos = $p7;
      $r6 = $this->a6($r3, $r9);
      goto choice_1;
    }
    // free $r13,$r10,$r14
    // free $p8
    // free $p7
    // start seq_9
    $p7 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
      $r14 = true;
      $r14 = false;
      $this->currPos = $p7;
    } else {
      $r14 = self::$FAILED;
      if (!$silence) { $this->fail(5); }
      $r6 = self::$FAILED;
      goto seq_9;
    }
    $r6 = $this->parsepipeline($silence, $boolParams);
    if ($r6===self::$FAILED) {
      $this->currPos = $p7;
      $r6 = self::$FAILED;
      goto seq_9;
    }
    seq_9:
    // free $p7
    choice_1:
    if ($r6!==self::$FAILED) {
      $r5[] = $r6;
    } else {
      break;
    }
  }
  // rest <- $r5
  // free $r6
  // free $r14
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a7($r3, $r5);
  }
  // free $r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardseparator_op() {
  $key = json_encode([79,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  $r3 = $this->input[$this->currPos] ?? '';
  if ($r3 === "&") {
    $r3 = false;
    $this->currPos = $p1;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = $this->discardAND();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === ";") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_2;
  }
  $r2 = $this->discardSEMI();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsepipeline($silence, $boolParams) {
  $key = json_encode([8,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "!") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(8); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parseBang($silence);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r3 = null;
  }
  // bang <- $r3
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(9); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsepipe_sequence($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // pipeline <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a8($r3, $r5);
  }
  // free $r4,$r7
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardAND_IF() {
  $key = json_encode([85,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "&&", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardOR_IF() {
  $key = json_encode([87,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "||", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardAND() {
  $key = json_encode([139,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "&") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardAND_IF();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3 === self::$FAILED) {
    $r3 = false;
  } else {
    $r3 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  if (($this->input[$this->currPos] ?? null) === "&") {
    $r5 = true;
    $this->currPos++;
  } else {
    $r5 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3,$r4,$r5
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardSEMI() {
  $key = json_encode([141,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === ";") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardDSEMI();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3 === self::$FAILED) {
    $r3 = false;
  } else {
    $r3 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  if (($this->input[$this->currPos] ?? null) === ";") {
    $r5 = true;
    $this->currPos++;
  } else {
    $r5 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3,$r4,$r5
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseBang($silence) {
  $key = json_encode([132,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "!") {
    $r3 = "!";
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(10); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->parseDELIM($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = [$r3,$r4];
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsepipe_sequence($silence, $boolParams) {
  $key = json_encode([10,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(11); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parsecommand($silence, $boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // first <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r5 = [];
  for (;;) {
    $p7 = $this->currPos;
    // start seq_3
    $p8 = $this->currPos;
    // start seq_4
    $r10 = $this->input[$this->currPos] ?? '';
    if ($r10 === "|") {
      $r10 = false;
      $this->currPos = $p8;
    } else {
      $r10 = self::$FAILED;
      if (!$silence) { $this->fail(12); }
      $r9 = self::$FAILED;
      goto seq_4;
    }
    $r9 = $this->discardPIPE();
    if ($r9===self::$FAILED) {
      $this->currPos = $p8;
      $r9 = self::$FAILED;
      goto seq_4;
    }
    seq_4:
    if ($r9===self::$FAILED) {
      $r6 = self::$FAILED;
      goto seq_3;
    }
    $this->discardlinebreak();
    // start seq_5
    $p12 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
      $r13 = true;
      $r13 = false;
      $this->currPos = $p12;
    } else {
      $r13 = self::$FAILED;
      if (!$silence) { $this->fail(11); }
      $r11 = self::$FAILED;
      goto seq_5;
    }
    $r11 = $this->parsecommand($silence, $boolParams);
    if ($r11===self::$FAILED) {
      $this->currPos = $p12;
      $r11 = self::$FAILED;
      goto seq_5;
    }
    seq_5:
    // command <- $r11
    if ($r11===self::$FAILED) {
      $this->currPos = $p8;
      $r6 = self::$FAILED;
      goto seq_3;
    }
    // free $p12
    $r6 = true;
    seq_3:
    if ($r6!==self::$FAILED) {
      $this->savedPos = $p7;
      $r6 = $this->a9($r3, $r11);
      $r5[] = $r6;
    } else {
      break;
    }
    // free $r9,$r10,$r13
    // free $p8
    // free $p7
  }
  // rest <- $r5
  // free $r6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a10($r3, $r5);
  }
  // free $r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardDSEMI() {
  $key = json_encode([89,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, ";;", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseDELIM($silence) {
  $key = json_encode([154,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  $r2 = strspn($this->input, "\x09\x0b\x0c\x0d ", $this->currPos);
  if ($r2 > 0) {
    $this->currPos += $r2;
    $r2 = substr($this->input, $this->currPos - $r2, $r2);
    $r2 = str_split($r2);
    goto choice_1;
  } else {
    $r2 = self::$FAILED;
    if (!$silence) { $this->fail(13); }
  }
  if ($this->currPos < $this->inputLength) {
    $r2 = true;
  } else {
    $r2 = self::$FAILED;
  }
  if ($r2 === self::$FAILED) {
    $r2 = false;
    goto choice_1;
  } else {
    $r2 = self::$FAILED;
    $this->currPos = $p1;
  }
  if (($this->input[$this->currPos] ?? null) === "\x0a") {
    $r2 = true;
    $r2 = false;
    $this->currPos = $p1;
  } else {
    $r2 = self::$FAILED;
  }
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecommand($silence, $boolParams) {
  $key = json_encode([12,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  $r3 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r3)) {
    $r3 = false;
    $this->currPos = $p1;
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(14); }
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = $this->parsefunction_definition($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_2
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();|", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(15); }
    $r2 = self::$FAILED;
    goto seq_2;
  }
  $r2 = $this->parsesimple_command($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_3
  // start seq_4
  if (strspn($this->input, "(cfiuw{", $this->currPos, 1) !== 0) {
    $r6 = true;
    $r6 = false;
    $this->currPos = $p1;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(16); }
    $r5 = self::$FAILED;
    goto seq_4;
  }
  $r5 = $this->parsecompound_command($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r5 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  // c <- $r5
  if ($r5===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_3;
  }
  // start seq_5
  $p8 = $this->currPos;
  if (strspn($this->input, "0123456789<>", $this->currPos, 1) !== 0) {
    $r9 = true;
    $r9 = false;
    $this->currPos = $p8;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(17); }
    $r7 = self::$FAILED;
    goto seq_5;
  }
  $r7 = $this->parseredirect_list($silence, $boolParams);
  if ($r7===self::$FAILED) {
    $this->currPos = $p8;
    $r7 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r7===self::$FAILED) {
    $r7 = null;
  }
  // free $p8
  // r <- $r7
  $r2 = true;
  seq_3:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a11($r5, $r7);
  }
  // free $r6,$r9
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardPIPE() {
  $key = json_encode([147,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "|") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardOR_IF();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3 === self::$FAILED) {
    $r3 = false;
  } else {
    $r3 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  if (($this->input[$this->currPos] ?? null) === "|") {
    $r5 = true;
    $this->currPos++;
  } else {
    $r5 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3,$r4,$r5
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsefunction_definition($silence, $boolParams) {
  $key = json_encode([48,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r4)) {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(18); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parseNAME($silence);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // fname <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === "(") {
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(19); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->discardLPAREN();
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === ")") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(20); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardRPAREN();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $this->discardlinebreak();
  // start seq_5
  $p6 = $this->currPos;
  if (strspn($this->input, "(cfiuw{", $this->currPos, 1) !== 0) {
    $r11 = true;
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(21); }
    $r10 = self::$FAILED;
    goto seq_5;
  }
  $r10 = $this->parsefunction_body($silence, $boolParams);
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  // body <- $r10
  if ($r10===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a12($r3, $r10);
  }
  // free $r4,$r5,$r7,$r8,$r9,$r11
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsesimple_command($silence, $boolParams) {
  $key = json_encode([56,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[0-9<>A-Z_a-z]/A", $r4)) {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(22); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parsecmd_prefix($silence, $boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // prefix <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parseWORD($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // word <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();|", $this->currPos, 1) !== 0) {
    $r9 = true;
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(24); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->parsecmd_suffix($silence, $boolParams);
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $r8 = null;
  }
  // free $p6
  // suffix <- $r8
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a13($r3, $r5, $r8);
    goto choice_1;
  }
  // free $r4,$r7,$r9
  // start seq_5
  $r7 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[0-9<>A-Z_a-z]/A", $r7)) {
    $r7 = false;
    $this->currPos = $p1;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(22); }
    $r9 = self::$FAILED;
    goto seq_5;
  }
  $r9 = $this->parsecmd_prefix($silence, $boolParams);
  if ($r9===self::$FAILED) {
    $this->currPos = $p1;
    $r9 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  // prefix <- $r9
  $r2 = $r9;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a14($r9);
    goto choice_1;
  }
  // free $r7
  // start seq_6
  // start seq_7
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(25); }
    $r7 = self::$FAILED;
    goto seq_7;
  }
  $r7 = $this->parsecmd_name($silence, $boolParams);
  if ($r7===self::$FAILED) {
    $this->currPos = $p1;
    $r7 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  // name <- $r7
  if ($r7===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_6;
  }
  // start seq_8
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();|", $this->currPos, 1) !== 0) {
    $r11 = true;
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(24); }
    $r10 = self::$FAILED;
    goto seq_8;
  }
  $r10 = $this->parsecmd_suffix($silence, $boolParams);
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_8;
  }
  seq_8:
  if ($r10===self::$FAILED) {
    $r10 = null;
  }
  // free $p6
  // suffix <- $r10
  $r2 = true;
  seq_6:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a15($r7, $r10);
  }
  // free $r4,$r11
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecompound_command($silence, $boolParams) {
  $key = json_encode([14,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  $r3 = $this->input[$this->currPos] ?? '';
  if ($r3 === "{") {
    $r3 = false;
    $this->currPos = $p1;
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(26); }
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = $this->parsebrace_group($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "(") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(27); }
    $r2 = self::$FAILED;
    goto seq_2;
  }
  $r2 = $this->parsesubshell($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_3
  $r5 = $this->input[$this->currPos] ?? '';
  if ($r5 === "f") {
    $r5 = false;
    $this->currPos = $p1;
  } else {
    $r5 = self::$FAILED;
    if (!$silence) { $this->fail(28); }
    $r2 = self::$FAILED;
    goto seq_3;
  }
  $r2 = $this->parsefor_clause($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_4
  $r6 = $this->input[$this->currPos] ?? '';
  if ($r6 === "c") {
    $r6 = false;
    $this->currPos = $p1;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(29); }
    $r2 = self::$FAILED;
    goto seq_4;
  }
  $r2 = $this->parsecase_clause($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_5
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === "i") {
    $r7 = false;
    $this->currPos = $p1;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(30); }
    $r2 = self::$FAILED;
    goto seq_5;
  }
  $r2 = $this->parseif_clause($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_6
  $r8 = $this->input[$this->currPos] ?? '';
  if ($r8 === "w") {
    $r8 = false;
    $this->currPos = $p1;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(31); }
    $r2 = self::$FAILED;
    goto seq_6;
  }
  $r2 = $this->parsewhile_clause($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_7
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "u") {
    $r9 = false;
    $this->currPos = $p1;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(32); }
    $r2 = self::$FAILED;
    goto seq_7;
  }
  $r2 = $this->parseuntil_clause($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseredirect_list($silence, $boolParams) {
  $key = json_encode([64,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $r2 = [];
  for (;;) {
    // start seq_1
    $p4 = $this->currPos;
    if (strspn($this->input, "0123456789<>", $this->currPos, 1) !== 0) {
      $r5 = true;
      $r5 = false;
      $this->currPos = $p4;
    } else {
      $r5 = self::$FAILED;
      if (!$silence) { $this->fail(33); }
      $r3 = self::$FAILED;
      goto seq_1;
    }
    $r3 = $this->parseio_redirect($silence, $boolParams);
    if ($r3===self::$FAILED) {
      $this->currPos = $p4;
      $r3 = self::$FAILED;
      goto seq_1;
    }
    seq_1:
    if ($r3!==self::$FAILED) {
      $r2[] = $r3;
    } else {
      break;
    }
    // free $p4
  }
  if (count($r2) === 0) {
    $r2 = self::$FAILED;
  }
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseNAME($silence) {
  $key = json_encode([202,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $p2 = $this->currPos;
  // start seq_1
  $r4 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r4)) {
    $this->currPos++;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(34); }
    $r3 = self::$FAILED;
    goto seq_1;
  }
  $r5 = null;
  if (preg_match("/[0-9A-Z_a-z]*/A", $this->input, $r5, 0, $this->currPos)) {
    $this->currPos += strlen($r5[0]);
    $r5 = true;
  } else {
    $r5 = self::$FAILED;
    if (!$silence) { $this->fail(35); }
  }
  $r3 = true;
  seq_1:
  if ($r3!==self::$FAILED) {
    $r3 = substr($this->input, $p2, $this->currPos - $p2);
  } else {
    $r3 = self::$FAILED;
  }
  // free $r4,$r5
  // free $p2
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r3

  );
  return $r3;
}
private function discardLPAREN() {
  $key = json_encode([149,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "(") {
    $r3 = true;
    $this->currPos++;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardRPAREN() {
  $key = json_encode([151,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === ")") {
    $r3 = true;
    $this->currPos++;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsefunction_body($silence, $boolParams) {
  $key = json_encode([50,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  if (strspn($this->input, "(cfiuw{", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(16); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parsecompound_command($silence, $boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // c <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strspn($this->input, "0123456789<>", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(17); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parseredirect_list($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r5===self::$FAILED) {
    $r5 = null;
  }
  // free $p6
  // r <- $r5
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a16($r3, $r5);
  }
  // free $r4,$r7
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecmd_prefix($silence, $boolParams) {
  $key = json_encode([60,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $r3 = [];
  for (;;) {
    // start choice_1
    // start seq_1
    $p5 = $this->currPos;
    if (strspn($this->input, "0123456789<>", $this->currPos, 1) !== 0) {
      $r6 = true;
      $r6 = false;
      $this->currPos = $p5;
    } else {
      $r6 = self::$FAILED;
      if (!$silence) { $this->fail(33); }
      $r4 = self::$FAILED;
      goto seq_1;
    }
    $r4 = $this->parseio_redirect($silence, $boolParams);
    if ($r4===self::$FAILED) {
      $this->currPos = $p5;
      $r4 = self::$FAILED;
      goto seq_1;
    }
    seq_1:
    if ($r4!==self::$FAILED) {
      goto choice_1;
    }
    // free $p5
    // start seq_2
    $p5 = $this->currPos;
    $r7 = $this->input[$this->currPos] ?? '';
    if (preg_match("/[A-Z_a-z]/A", $r7)) {
      $r7 = false;
      $this->currPos = $p5;
    } else {
      $r7 = self::$FAILED;
      if (!$silence) { $this->fail(36); }
      $r4 = self::$FAILED;
      goto seq_2;
    }
    $r4 = $this->parseASSIGNMENT_WORD($silence, $boolParams);
    if ($r4===self::$FAILED) {
      $this->currPos = $p5;
      $r4 = self::$FAILED;
      goto seq_2;
    }
    seq_2:
    // free $p5
    choice_1:
    if ($r4!==self::$FAILED) {
      $r3[] = $r4;
    } else {
      break;
    }
  }
  if (count($r3) === 0) {
    $r3 = self::$FAILED;
  }
  // contents <- $r3
  // free $r4
  $r2 = $r3;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a17($r3);
  }
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseWORD($silence, $boolParams) {
  $key = json_encode([156,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $r3 = [];
  for (;;) {
    // start seq_2
    $p5 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
      $r6 = true;
      $r6 = false;
      $this->currPos = $p5;
    } else {
      $r6 = self::$FAILED;
      if (!$silence) { $this->fail(37); }
      $r4 = self::$FAILED;
      goto seq_2;
    }
    $r4 = $this->parseword_part($silence, $boolParams);
    if ($r4===self::$FAILED) {
      $this->currPos = $p5;
      $r4 = self::$FAILED;
      goto seq_2;
    }
    seq_2:
    if ($r4!==self::$FAILED) {
      $r3[] = $r4;
    } else {
      break;
    }
    // free $p5
  }
  if (count($r3) === 0) {
    $r3 = self::$FAILED;
  }
  // parts <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $r4
  $this->discardOWS();
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a18($r3);
  }
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecmd_suffix($silence, $boolParams) {
  $key = json_encode([62,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $r2 = [];
  for (;;) {
    // start choice_1
    // start seq_1
    $p4 = $this->currPos;
    if (strspn($this->input, "0123456789<>", $this->currPos, 1) !== 0) {
      $r5 = true;
      $r5 = false;
      $this->currPos = $p4;
    } else {
      $r5 = self::$FAILED;
      if (!$silence) { $this->fail(33); }
      $r3 = self::$FAILED;
      goto seq_1;
    }
    $r3 = $this->parseio_redirect($silence, $boolParams);
    if ($r3===self::$FAILED) {
      $this->currPos = $p4;
      $r3 = self::$FAILED;
      goto seq_1;
    }
    seq_1:
    if ($r3!==self::$FAILED) {
      goto choice_1;
    }
    // free $p4
    // start seq_2
    $p4 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
      $r6 = true;
      $r6 = false;
      $this->currPos = $p4;
    } else {
      $r6 = self::$FAILED;
      if (!$silence) { $this->fail(23); }
      $r3 = self::$FAILED;
      goto seq_2;
    }
    $r3 = $this->parseWORD($silence, $boolParams);
    if ($r3===self::$FAILED) {
      $this->currPos = $p4;
      $r3 = self::$FAILED;
      goto seq_2;
    }
    seq_2:
    // free $p4
    choice_1:
    if ($r3!==self::$FAILED) {
      $r2[] = $r3;
    } else {
      break;
    }
  }
  if (count($r2) === 0) {
    $r2 = self::$FAILED;
  }
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecmd_name($silence, $boolParams) {
  $key = json_encode([58,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  if (strspn($this->input, "!cdefituw{}", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardreserved();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3 === self::$FAILED) {
    $r3 = false;
  } else {
    $r3 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parseWORD($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // word <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a19($r5);
  }
  // free $r3,$r4,$r7
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsebrace_group($silence, $boolParams) {
  $key = json_encode([52,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "{") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(38); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardLbrace();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsecompound_list($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // list <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "}") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(40); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardRbrace();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a20($r5);
  }
  // free $r3,$r4,$r7,$r8,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsesubshell($silence, $boolParams) {
  $key = json_encode([16,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "(") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(19); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardLPAREN();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsecompound_list($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // list <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === ")") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(20); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardRPAREN();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a21($r5);
  }
  // free $r3,$r4,$r7,$r8,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsefor_clause($silence, $boolParams) {
  $key = json_encode([20,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "f") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(41); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardFor();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  $r7 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r7)) {
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(42); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsefor_name($silence);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // name <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $this->discardlinebreak();
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "i") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(43); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardfor_case_in();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_5
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r11 = true;
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(44); }
    $r10 = self::$FAILED;
    goto seq_5;
  }
  $r10 = $this->parsewordlist($silence, $boolParams);
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r10===self::$FAILED) {
    $r10 = null;
  }
  // free $p6
  // wordlist <- $r10
  // start seq_6
  $p6 = $this->currPos;
  $r13 = $this->input[$this->currPos] ?? '';
  if ($r13 === "\x0a" || $r13 === ";") {
    $r13 = false;
    $this->currPos = $p6;
  } else {
    $r13 = self::$FAILED;
    if (!$silence) { $this->fail(45); }
    $r12 = self::$FAILED;
    goto seq_6;
  }
  $r12 = $this->discardsequential_sep();
  if ($r12===self::$FAILED) {
    $this->currPos = $p6;
    $r12 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r12===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_7
  $p6 = $this->currPos;
  $r15 = $this->input[$this->currPos] ?? '';
  if ($r15 === "d") {
    $r15 = false;
    $this->currPos = $p6;
  } else {
    $r15 = self::$FAILED;
    if (!$silence) { $this->fail(46); }
    $r14 = self::$FAILED;
    goto seq_7;
  }
  $r14 = $this->parsedo_group($silence, $boolParams);
  if ($r14===self::$FAILED) {
    $this->currPos = $p6;
    $r14 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  // do_group <- $r14
  if ($r14===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a22($r5, $r10, $r14);
    goto choice_1;
  }
  // free $r3,$r4,$r7,$r8,$r9,$r11,$r12,$r13,$r15
  // start seq_8
  // start seq_9
  $r13 = $this->input[$this->currPos] ?? '';
  if ($r13 === "f") {
    $r13 = false;
    $this->currPos = $p1;
  } else {
    $r13 = self::$FAILED;
    if (!$silence) { $this->fail(41); }
    $r15 = self::$FAILED;
    goto seq_9;
  }
  $r15 = $this->discardFor();
  if ($r15===self::$FAILED) {
    $this->currPos = $p1;
    $r15 = self::$FAILED;
    goto seq_9;
  }
  seq_9:
  if ($r15===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_8;
  }
  // start seq_10
  $p6 = $this->currPos;
  $r11 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r11)) {
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(42); }
    $r12 = self::$FAILED;
    goto seq_10;
  }
  $r12 = $this->parsefor_name($silence);
  if ($r12===self::$FAILED) {
    $this->currPos = $p6;
    $r12 = self::$FAILED;
    goto seq_10;
  }
  seq_10:
  // name <- $r12
  if ($r12===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_8;
  }
  // free $p6
  // start seq_11
  $p6 = $this->currPos;
  $r8 = $this->input[$this->currPos] ?? '';
  if ($r8 === "\x0a" || $r8 === ";") {
    $r8 = false;
    $this->currPos = $p6;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(45); }
    $r9 = self::$FAILED;
    goto seq_11;
  }
  $r9 = $this->discardsequential_sep();
  if ($r9===self::$FAILED) {
    $this->currPos = $p6;
    $r9 = self::$FAILED;
    goto seq_11;
  }
  seq_11:
  if ($r9===self::$FAILED) {
    $r9 = null;
  }
  // free $p6
  // start seq_12
  $p6 = $this->currPos;
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "d") {
    $r4 = false;
    $this->currPos = $p6;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(46); }
    $r7 = self::$FAILED;
    goto seq_12;
  }
  $r7 = $this->parsedo_group($silence, $boolParams);
  if ($r7===self::$FAILED) {
    $this->currPos = $p6;
    $r7 = self::$FAILED;
    goto seq_12;
  }
  seq_12:
  // do_group <- $r7
  if ($r7===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_8;
  }
  // free $p6
  $r2 = true;
  seq_8:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a23($r12, $r7);
  }
  // free $r15,$r13,$r11,$r9,$r8,$r4
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecase_clause($silence, $boolParams) {
  $key = json_encode([28,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "c") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(47); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardCase();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parseWORD($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // word <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $this->discardlinebreak();
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "i") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(43); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardfor_case_in();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $this->discardlinebreak();
  // start choice_1
  // start seq_5
  $p6 = $this->currPos;
  // start seq_6
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);<>|", $this->currPos, 1) !== 0) {
    $r12 = true;
    $r12 = false;
    $this->currPos = $p6;
  } else {
    $r12 = self::$FAILED;
    if (!$silence) { $this->fail(48); }
    $r11 = self::$FAILED;
    goto seq_6;
  }
  $r11 = $this->parsecase_list($silence, $boolParams);
  if ($r11===self::$FAILED) {
    $this->currPos = $p6;
    $r11 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r11===self::$FAILED) {
    $r10 = self::$FAILED;
    goto seq_5;
  }
  $p13 = $this->currPos;
  // start seq_7
  $p15 = $this->currPos;
  $r16 = $this->input[$this->currPos] ?? '';
  if ($r16 === "e") {
    $r16 = false;
    $this->currPos = $p15;
  } else {
    $r16 = self::$FAILED;
    if (!$silence) { $this->fail(49); }
    $r14 = self::$FAILED;
    goto seq_7;
  }
  $r14 = $this->discardEsac();
  if ($r14===self::$FAILED) {
    $this->currPos = $p15;
    $r14 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  if ($r14!==self::$FAILED) {
    $r14 = substr($this->input, $p13, $this->currPos - $p13);
  } else {
    $r14 = self::$FAILED;
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  // free $p15
  // free $p13
  $r10 = [$r11,$r14];
  seq_5:
  if ($r10!==self::$FAILED) {
    goto choice_1;
  }
  // free $r11,$r12,$r14,$r16
  // free $p6
  // start seq_8
  $p6 = $this->currPos;
  // start seq_9
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);<>|", $this->currPos, 1) !== 0) {
    $r14 = true;
    $r14 = false;
    $this->currPos = $p6;
  } else {
    $r14 = self::$FAILED;
    if (!$silence) { $this->fail(50); }
    $r16 = self::$FAILED;
    goto seq_9;
  }
  $r16 = $this->parsecase_list_ns($silence, $boolParams);
  if ($r16===self::$FAILED) {
    $this->currPos = $p6;
    $r16 = self::$FAILED;
    goto seq_9;
  }
  seq_9:
  if ($r16===self::$FAILED) {
    $r10 = self::$FAILED;
    goto seq_8;
  }
  $p13 = $this->currPos;
  // start seq_10
  $p15 = $this->currPos;
  $r11 = $this->input[$this->currPos] ?? '';
  if ($r11 === "e") {
    $r11 = false;
    $this->currPos = $p15;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(49); }
    $r12 = self::$FAILED;
    goto seq_10;
  }
  $r12 = $this->discardEsac();
  if ($r12===self::$FAILED) {
    $this->currPos = $p15;
    $r12 = self::$FAILED;
    goto seq_10;
  }
  seq_10:
  if ($r12!==self::$FAILED) {
    $r12 = substr($this->input, $p13, $this->currPos - $p13);
  } else {
    $r12 = self::$FAILED;
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_8;
  }
  // free $p15
  // free $p13
  $r10 = [$r16,$r12];
  seq_8:
  if ($r10!==self::$FAILED) {
    goto choice_1;
  }
  // free $r16,$r14,$r12,$r11
  // free $p6
  $p6 = $this->currPos;
  // start seq_11
  $p13 = $this->currPos;
  $r11 = $this->input[$this->currPos] ?? '';
  if ($r11 === "e") {
    $r11 = false;
    $this->currPos = $p13;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(49); }
    $r10 = self::$FAILED;
    goto seq_11;
  }
  $r10 = $this->discardEsac();
  if ($r10===self::$FAILED) {
    $this->currPos = $p13;
    $r10 = self::$FAILED;
    goto seq_11;
  }
  seq_11:
  if ($r10!==self::$FAILED) {
    $r10 = substr($this->input, $p6, $this->currPos - $p6);
  } else {
    $r10 = self::$FAILED;
  }
  // free $p13
  // free $p6
  choice_1:
  // list_esac <- $r10
  if ($r10===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a24($r5, $r10);
  }
  // free $r3,$r4,$r7,$r8,$r9,$r11
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseif_clause($silence, $boolParams) {
  $key = json_encode([40,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "i") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(51); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardIf();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsecompound_list($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // condition <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "t") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(52); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardThen();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_5
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r11 = true;
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r10 = self::$FAILED;
    goto seq_5;
  }
  $r10 = $this->parsecompound_list($silence, $boolParams);
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  // consequent <- $r10
  if ($r10===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_6
  $p6 = $this->currPos;
  $r13 = $this->input[$this->currPos] ?? '';
  if ($r13 === "e") {
    $r13 = false;
    $this->currPos = $p6;
  } else {
    $r13 = self::$FAILED;
    if (!$silence) { $this->fail(53); }
    $r12 = self::$FAILED;
    goto seq_6;
  }
  $r12 = $this->parseelse_part($silence, $boolParams);
  if ($r12===self::$FAILED) {
    $this->currPos = $p6;
    $r12 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r12===self::$FAILED) {
    $r12 = null;
  }
  // free $p6
  // else_part <- $r12
  // start seq_7
  $p6 = $this->currPos;
  $r15 = $this->input[$this->currPos] ?? '';
  if ($r15 === "f") {
    $r15 = false;
    $this->currPos = $p6;
  } else {
    $r15 = self::$FAILED;
    if (!$silence) { $this->fail(54); }
    $r14 = self::$FAILED;
    goto seq_7;
  }
  $r14 = $this->discardFi();
  if ($r14===self::$FAILED) {
    $this->currPos = $p6;
    $r14 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  if ($r14===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a25($r5, $r10, $r12);
  }
  // free $r3,$r4,$r7,$r8,$r9,$r11,$r13,$r14,$r15
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsewhile_clause($silence, $boolParams) {
  $key = json_encode([44,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "w") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(55); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardWhile();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsecompound_list($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // list <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "d") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(46); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->parsedo_group($silence, $boolParams);
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  // body <- $r8
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a26($r5, $r8);
  }
  // free $r3,$r4,$r7,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseuntil_clause($silence, $boolParams) {
  $key = json_encode([46,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "u") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(56); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardUntil();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsecompound_list($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // list <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "d") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(46); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->parsedo_group($silence, $boolParams);
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  // body <- $r8
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a27($r5, $r8);
  }
  // free $r3,$r4,$r7,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseio_redirect($silence, $boolParams) {
  $key = json_encode([66,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $p4 = $this->currPos;
  $r3 = strspn($this->input, "0123456789", $this->currPos);
  if ($r3 > 0) {
    $this->currPos += $r3;
    $r3 = substr($this->input, $p4, $this->currPos - $p4);
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(57); }
    $r3 = self::$FAILED;
    $r3 = null;
  }
  // free $p4
  // number <- $r3
  // start choice_1
  // start seq_2
  $p4 = $this->currPos;
  $r6 = $this->input[$this->currPos] ?? '';
  if ($r6 === "<" || $r6 === ">") {
    $r6 = false;
    $this->currPos = $p4;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(58); }
    $r5 = self::$FAILED;
    goto seq_2;
  }
  $r5 = $this->parseio_file($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p4;
    $r5 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r5!==self::$FAILED) {
    goto choice_1;
  }
  // free $p4
  // start seq_3
  $p4 = $this->currPos;
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === "<") {
    $r7 = false;
    $this->currPos = $p4;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(59); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parseio_here($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p4;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // free $p4
  choice_1:
  // file_or_here <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a28($r3, $r5);
  }
  // free $r6,$r7
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseASSIGNMENT_WORD($silence, $boolParams) {
  $key = json_encode([200,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r4)) {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(18); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parseNAME($silence);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // name <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  if (($this->input[$this->currPos] ?? null) === "=") {
    $r5 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(60); }
    $r5 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p7 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r8 = true;
    $r8 = false;
    $this->currPos = $p7;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r6 = self::$FAILED;
    goto seq_3;
  }
  $r6 = $this->parseWORD($silence, $boolParams);
  if ($r6===self::$FAILED) {
    $this->currPos = $p7;
    $r6 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // word <- $r6
  if ($r6===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p7
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a29($r3, $r6);
  }
  // free $r4,$r5,$r8
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseword_part($silence, $boolParams) {
  $key = json_encode([158,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  $r3 = $this->input[$this->currPos] ?? '';
  if ($r3 === "'") {
    $r3 = false;
    $this->currPos = $p1;
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(61); }
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = $this->parsesingle_quoted_part($silence);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "\"") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(62); }
    $r2 = self::$FAILED;
    goto seq_2;
  }
  $r2 = $this->parsedouble_quoted_part($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_3
  $r5 = $this->input[$this->currPos] ?? '';
  if ($r5 === "\\") {
    $r5 = false;
    $this->currPos = $p1;
  } else {
    $r5 = self::$FAILED;
    if (!$silence) { $this->fail(63); }
    $r2 = self::$FAILED;
    goto seq_3;
  }
  $r2 = $this->parsebare_escape_sequence($silence);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_4
  $r6 = $this->input[$this->currPos] ?? '';
  if ($r6 === "`") {
    $r6 = false;
    $this->currPos = $p1;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(64); }
    $r2 = self::$FAILED;
    goto seq_4;
  }
  $r2 = $this->parsebackquote_expansion($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_5
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === "\$") {
    $r7 = false;
    $this->currPos = $p1;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(65); }
    $r2 = self::$FAILED;
    goto seq_5;
  }
  $r2 = $this->parsedollar_expansion($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_6
  if (preg_match("/[^\\x09-\\x0d \"\$&-);-<>\\\\`|]/A", $this->input, $r8, 0, $this->currPos)) {
    $r8 = $r8[0];
    $r8 = false;
    $this->currPos = $p1;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(66); }
    $r2 = self::$FAILED;
    goto seq_6;
  }
  $r2 = $this->parseplain_part($silence, $boolParams);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardreserved() {
  $key = json_encode([137,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  $r3 = $this->input[$this->currPos] ?? '';
  if ($r3 === "i") {
    $r3 = false;
    $this->currPos = $p1;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = $this->discardIf();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "t") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_2;
  }
  $r2 = $this->discardThen();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_3
  $r5 = $this->input[$this->currPos] ?? '';
  if ($r5 === "e") {
    $r5 = false;
    $this->currPos = $p1;
  } else {
    $r5 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  $r2 = $this->discardElse();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_4
  $r6 = $this->input[$this->currPos] ?? '';
  if ($r6 === "e") {
    $r6 = false;
    $this->currPos = $p1;
  } else {
    $r6 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_4;
  }
  $r2 = $this->discardElif();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_5
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === "f") {
    $r7 = false;
    $this->currPos = $p1;
  } else {
    $r7 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_5;
  }
  $r2 = $this->discardFi();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_6
  $r8 = $this->input[$this->currPos] ?? '';
  if ($r8 === "d") {
    $r8 = false;
    $this->currPos = $p1;
  } else {
    $r8 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_6;
  }
  $r2 = $this->discardDo();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_7
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "d") {
    $r9 = false;
    $this->currPos = $p1;
  } else {
    $r9 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_7;
  }
  $r2 = $this->discardDone();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_8
  $r10 = $this->input[$this->currPos] ?? '';
  if ($r10 === "c") {
    $r10 = false;
    $this->currPos = $p1;
  } else {
    $r10 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_8;
  }
  $r2 = $this->discardCase();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_8;
  }
  seq_8:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_9
  $r11 = $this->input[$this->currPos] ?? '';
  if ($r11 === "e") {
    $r11 = false;
    $this->currPos = $p1;
  } else {
    $r11 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_9;
  }
  $r2 = $this->discardEsac();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_9;
  }
  seq_9:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_10
  $r12 = $this->input[$this->currPos] ?? '';
  if ($r12 === "w") {
    $r12 = false;
    $this->currPos = $p1;
  } else {
    $r12 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_10;
  }
  $r2 = $this->discardWhile();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_10;
  }
  seq_10:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_11
  $r13 = $this->input[$this->currPos] ?? '';
  if ($r13 === "u") {
    $r13 = false;
    $this->currPos = $p1;
  } else {
    $r13 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_11;
  }
  $r2 = $this->discardUntil();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_11;
  }
  seq_11:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_12
  $r14 = $this->input[$this->currPos] ?? '';
  if ($r14 === "f") {
    $r14 = false;
    $this->currPos = $p1;
  } else {
    $r14 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_12;
  }
  $r2 = $this->discardFor();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_12;
  }
  seq_12:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_13
  $r15 = $this->input[$this->currPos] ?? '';
  if ($r15 === "{") {
    $r15 = false;
    $this->currPos = $p1;
  } else {
    $r15 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_13;
  }
  $r2 = $this->discardLbrace();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_13;
  }
  seq_13:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_14
  $r16 = $this->input[$this->currPos] ?? '';
  if ($r16 === "}") {
    $r16 = false;
    $this->currPos = $p1;
  } else {
    $r16 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_14;
  }
  $r2 = $this->discardRbrace();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_14;
  }
  seq_14:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_15
  $r17 = $this->input[$this->currPos] ?? '';
  if ($r17 === "!") {
    $r17 = false;
    $this->currPos = $p1;
  } else {
    $r17 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_15;
  }
  $r2 = $this->discardBang();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_15;
  }
  seq_15:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_16
  $r18 = $this->input[$this->currPos] ?? '';
  if ($r18 === "i") {
    $r18 = false;
    $this->currPos = $p1;
  } else {
    $r18 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_16;
  }
  $r2 = $this->discardIn();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_16;
  }
  seq_16:
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardLbrace() {
  $key = json_encode([129,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "{") {
    $r3 = true;
    $this->currPos++;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecompound_list($silence, $boolParams) {
  $key = json_encode([18,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  $this->discardlinebreak();
  $r3 = [];
  for (;;) {
    $p5 = $this->currPos;
    // start seq_2
    $p6 = $this->currPos;
    // start seq_3
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
      $r8 = true;
      $r8 = false;
      $this->currPos = $p6;
    } else {
      $r8 = self::$FAILED;
      if (!$silence) { $this->fail(3); }
      $r7 = self::$FAILED;
      goto seq_3;
    }
    $r7 = $this->parseand_or($silence, $boolParams);
    if ($r7===self::$FAILED) {
      $this->currPos = $p6;
      $r7 = self::$FAILED;
      goto seq_3;
    }
    seq_3:
    // term <- $r7
    if ($r7===self::$FAILED) {
      $r4 = self::$FAILED;
      goto seq_2;
    }
    $p10 = $this->currPos;
    // start seq_4
    $p11 = $this->currPos;
    if (strspn($this->input, "\x0a&;", $this->currPos, 1) !== 0) {
      $r12 = true;
      $r12 = false;
      $this->currPos = $p11;
    } else {
      $r12 = self::$FAILED;
      if (!$silence) { $this->fail(67); }
      $r9 = self::$FAILED;
      goto seq_4;
    }
    $r9 = $this->discardseparator();
    if ($r9===self::$FAILED) {
      $this->currPos = $p11;
      $r9 = self::$FAILED;
      goto seq_4;
    }
    seq_4:
    // separator <- $r9
    if ($r9!==self::$FAILED) {
      $r9 = substr($this->input, $p10, $this->currPos - $p10);
    } else {
      $r9 = self::$FAILED;
      $this->currPos = $p6;
      $r4 = self::$FAILED;
      goto seq_2;
    }
    // free $p11
    // free $p10
    $r4 = true;
    seq_2:
    if ($r4!==self::$FAILED) {
      $this->savedPos = $p5;
      $r4 = $this->a30($r7, $r9);
      $r3[] = $r4;
    } else {
      break;
    }
    // free $r8,$r12
    // free $p6
    // free $p5
  }
  if (count($r3) === 0) {
    $r3 = self::$FAILED;
  }
  // terms <- $r3
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $r4
  // start seq_5
  $p5 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r12 = true;
    $r12 = false;
    $this->currPos = $p5;
  } else {
    $r12 = self::$FAILED;
    if (!$silence) { $this->fail(3); }
    $r4 = self::$FAILED;
    goto seq_5;
  }
  $r4 = $this->parseand_or($silence, $boolParams);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r4===self::$FAILED) {
    $r4 = null;
  }
  // free $p5
  // last <- $r4
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a31($r3, $r4);
    goto choice_1;
  }
  // free $r12
  // start seq_6
  $this->discardlinebreak();
  // start seq_7
  $p5 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r8 = true;
    $r8 = false;
    $this->currPos = $p5;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(3); }
    $r12 = self::$FAILED;
    goto seq_7;
  }
  $r12 = $this->parseand_or($silence, $boolParams);
  if ($r12===self::$FAILED) {
    $this->currPos = $p5;
    $r12 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  // term <- $r12
  if ($r12===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_6;
  }
  // free $p5
  $r2 = true;
  seq_6:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a32($r12);
  }
  // free $r8
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardRbrace() {
  $key = json_encode([131,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "}") {
    $r3 = true;
    $this->currPos++;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardFor() {
  $key = json_encode([127,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "for", $this->currPos, 3, false) === 0) {
    $r3 = true;
    $this->currPos += 3;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsefor_name($silence) {
  $key = json_encode([22,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r4)) {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(18); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parseNAME($silence);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // name <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a33($r3);
  }
  // free $r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardfor_case_in() {
  $key = json_encode([25,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "i") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardIn();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsewordlist($silence, $boolParams) {
  $key = json_encode([26,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $r2 = [];
  for (;;) {
    // start seq_1
    $p4 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
      $r5 = true;
      $r5 = false;
      $this->currPos = $p4;
    } else {
      $r5 = self::$FAILED;
      if (!$silence) { $this->fail(23); }
      $r3 = self::$FAILED;
      goto seq_1;
    }
    $r3 = $this->parseWORD($silence, $boolParams);
    if ($r3===self::$FAILED) {
      $this->currPos = $p4;
      $r3 = self::$FAILED;
      goto seq_1;
    }
    seq_1:
    if ($r3!==self::$FAILED) {
      $r2[] = $r3;
    } else {
      break;
    }
    // free $p4
  }
  if (count($r2) === 0) {
    $r2 = self::$FAILED;
  }
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardsequential_sep() {
  $key = json_encode([83,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === ";") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardSEMI();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardlinebreak();
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // free $r3,$r4
  // start seq_3
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "\x0a") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  $r2 = $this->discardnewline_list();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsedo_group($silence, $boolParams) {
  $key = json_encode([54,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "d") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(68); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardDo();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsecompound_list($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // list <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "d") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(69); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardDone();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a34($r5);
  }
  // free $r3,$r4,$r7,$r8,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardCase() {
  $key = json_encode([119,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "case", $this->currPos, 4, false) === 0) {
    $r3 = true;
    $this->currPos += 4;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecase_list($silence, $boolParams) {
  $key = json_encode([32,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $r2 = [];
  for (;;) {
    // start seq_1
    $p4 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);<>|", $this->currPos, 1) !== 0) {
      $r5 = true;
      $r5 = false;
      $this->currPos = $p4;
    } else {
      $r5 = self::$FAILED;
      if (!$silence) { $this->fail(70); }
      $r3 = self::$FAILED;
      goto seq_1;
    }
    $r3 = $this->parsecase_item($silence, $boolParams);
    if ($r3===self::$FAILED) {
      $this->currPos = $p4;
      $r3 = self::$FAILED;
      goto seq_1;
    }
    seq_1:
    if ($r3!==self::$FAILED) {
      $r2[] = $r3;
    } else {
      break;
    }
    // free $p4
  }
  if (count($r2) === 0) {
    $r2 = self::$FAILED;
  }
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardEsac() {
  $key = json_encode([121,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "esac", $this->currPos, 4, false) === 0) {
    $r3 = true;
    $this->currPos += 4;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecase_list_ns($silence, $boolParams) {
  $key = json_encode([30,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);<>|", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(48); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parsecase_list($silence, $boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // list <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);<>|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(71); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsecase_item_ns($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // item <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a35($r3, $r5);
    goto choice_1;
  }
  // free $r4,$r7
  // start seq_4
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &);<>|", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(71); }
    $r7 = self::$FAILED;
    goto seq_4;
  }
  $r7 = $this->parsecase_item_ns($silence, $boolParams);
  if ($r7===self::$FAILED) {
    $this->currPos = $p1;
    $r7 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  // item <- $r7
  $r2 = $r7;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a36($r7);
  }
  // free $r4
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardIf() {
  $key = json_encode([105,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "if", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardThen() {
  $key = json_encode([107,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "then", $this->currPos, 4, false) === 0) {
    $r3 = true;
    $this->currPos += 4;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseelse_part($silence, $boolParams) {
  $key = json_encode([42,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "e") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(72); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardElif();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsecompound_list($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // condition <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "t") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(52); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardThen();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_5
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r11 = true;
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r10 = self::$FAILED;
    goto seq_5;
  }
  $r10 = $this->parsecompound_list($silence, $boolParams);
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  // consequent <- $r10
  if ($r10===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_6
  $p6 = $this->currPos;
  $r13 = $this->input[$this->currPos] ?? '';
  if ($r13 === "e") {
    $r13 = false;
    $this->currPos = $p6;
  } else {
    $r13 = self::$FAILED;
    if (!$silence) { $this->fail(53); }
    $r12 = self::$FAILED;
    goto seq_6;
  }
  $r12 = $this->parseelse_part($silence, $boolParams);
  if ($r12===self::$FAILED) {
    $this->currPos = $p6;
    $r12 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r12===self::$FAILED) {
    $r12 = null;
  }
  // free $p6
  // else_part <- $r12
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a37($r5, $r10, $r12);
    goto choice_1;
  }
  // free $r3,$r4,$r7,$r8,$r9,$r11,$r13
  // start seq_7
  // start seq_8
  $r11 = $this->input[$this->currPos] ?? '';
  if ($r11 === "e") {
    $r11 = false;
    $this->currPos = $p1;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(73); }
    $r13 = self::$FAILED;
    goto seq_8;
  }
  $r13 = $this->discardElse();
  if ($r13===self::$FAILED) {
    $this->currPos = $p1;
    $r13 = self::$FAILED;
    goto seq_8;
  }
  seq_8:
  if ($r13===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_7;
  }
  // start seq_9
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r8 = true;
    $r8 = false;
    $this->currPos = $p6;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r9 = self::$FAILED;
    goto seq_9;
  }
  $r9 = $this->parsecompound_list($silence, $boolParams);
  if ($r9===self::$FAILED) {
    $this->currPos = $p6;
    $r9 = self::$FAILED;
    goto seq_9;
  }
  seq_9:
  // alternative <- $r9
  if ($r9===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_7;
  }
  // free $p6
  $r2 = true;
  seq_7:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a38($r9);
  }
  // free $r13,$r11,$r8
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardFi() {
  $key = json_encode([113,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "fi", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardWhile() {
  $key = json_encode([123,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "while", $this->currPos, 5, false) === 0) {
    $r3 = true;
    $this->currPos += 5;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardUntil() {
  $key = json_encode([125,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "until", $this->currPos, 5, false) === 0) {
    $r3 = true;
    $this->currPos += 5;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseio_file($silence, $boolParams) {
  $key = json_encode([68,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "<") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(74); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardLESSAND();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parseWORD($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // filename <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a39($r5);
    goto choice_1;
  }
  // free $r3,$r4,$r7
  // start seq_4
  // start seq_5
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "<") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(75); }
    $r7 = self::$FAILED;
    goto seq_5;
  }
  $r7 = $this->discardLESSGREAT();
  if ($r7===self::$FAILED) {
    $this->currPos = $p1;
    $r7 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r7===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_4;
  }
  // start seq_6
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r8 = true;
    $r8 = false;
    $this->currPos = $p6;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r3 = self::$FAILED;
    goto seq_6;
  }
  $r3 = $this->parseWORD($silence, $boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p6;
    $r3 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  // filename <- $r3
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_4;
  }
  // free $p6
  $r2 = true;
  seq_4:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a40($r3);
    goto choice_1;
  }
  // free $r7,$r4,$r8
  // start seq_7
  // start seq_8
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "<") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(76); }
    $r8 = self::$FAILED;
    goto seq_8;
  }
  $r8 = $this->discardLESS();
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r8 = self::$FAILED;
    goto seq_8;
  }
  seq_8:
  if ($r8===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_7;
  }
  // start seq_9
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r9 = true;
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r7 = self::$FAILED;
    goto seq_9;
  }
  $r7 = $this->parseWORD($silence, $boolParams);
  if ($r7===self::$FAILED) {
    $this->currPos = $p6;
    $r7 = self::$FAILED;
    goto seq_9;
  }
  seq_9:
  // filename <- $r7
  if ($r7===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_7;
  }
  // free $p6
  $r2 = true;
  seq_7:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a41($r7);
    goto choice_1;
  }
  // free $r8,$r4,$r9
  // start seq_10
  // start seq_11
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === ">") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(77); }
    $r9 = self::$FAILED;
    goto seq_11;
  }
  $r9 = $this->discardGREATAND();
  if ($r9===self::$FAILED) {
    $this->currPos = $p1;
    $r9 = self::$FAILED;
    goto seq_11;
  }
  seq_11:
  if ($r9===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_10;
  }
  // start seq_12
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r10 = true;
    $r10 = false;
    $this->currPos = $p6;
  } else {
    $r10 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r8 = self::$FAILED;
    goto seq_12;
  }
  $r8 = $this->parseWORD($silence, $boolParams);
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_12;
  }
  seq_12:
  // filename <- $r8
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_10;
  }
  // free $p6
  $r2 = true;
  seq_10:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a42($r8);
    goto choice_1;
  }
  // free $r9,$r4,$r10
  // start seq_13
  // start seq_14
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === ">") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(78); }
    $r10 = self::$FAILED;
    goto seq_14;
  }
  $r10 = $this->discardDGREAT();
  if ($r10===self::$FAILED) {
    $this->currPos = $p1;
    $r10 = self::$FAILED;
    goto seq_14;
  }
  seq_14:
  if ($r10===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_13;
  }
  // start seq_15
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r11 = true;
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r9 = self::$FAILED;
    goto seq_15;
  }
  $r9 = $this->parseWORD($silence, $boolParams);
  if ($r9===self::$FAILED) {
    $this->currPos = $p6;
    $r9 = self::$FAILED;
    goto seq_15;
  }
  seq_15:
  // filename <- $r9
  if ($r9===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_13;
  }
  // free $p6
  $r2 = true;
  seq_13:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a43($r9);
    goto choice_1;
  }
  // free $r10,$r4,$r11
  // start seq_16
  // start seq_17
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === ">") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(79); }
    $r11 = self::$FAILED;
    goto seq_17;
  }
  $r11 = $this->discardCLOBBER();
  if ($r11===self::$FAILED) {
    $this->currPos = $p1;
    $r11 = self::$FAILED;
    goto seq_17;
  }
  seq_17:
  if ($r11===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_16;
  }
  // start seq_18
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r12 = true;
    $r12 = false;
    $this->currPos = $p6;
  } else {
    $r12 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r10 = self::$FAILED;
    goto seq_18;
  }
  $r10 = $this->parseWORD($silence, $boolParams);
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_18;
  }
  seq_18:
  // filename <- $r10
  if ($r10===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_16;
  }
  // free $p6
  $r2 = true;
  seq_16:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a44($r10);
    goto choice_1;
  }
  // free $r11,$r4,$r12
  // start seq_19
  // start seq_20
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === ">") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(80); }
    $r12 = self::$FAILED;
    goto seq_20;
  }
  $r12 = $this->discardGREAT();
  if ($r12===self::$FAILED) {
    $this->currPos = $p1;
    $r12 = self::$FAILED;
    goto seq_20;
  }
  seq_20:
  if ($r12===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_19;
  }
  // start seq_21
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r13 = true;
    $r13 = false;
    $this->currPos = $p6;
  } else {
    $r13 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r11 = self::$FAILED;
    goto seq_21;
  }
  $r11 = $this->parseWORD($silence, $boolParams);
  if ($r11===self::$FAILED) {
    $this->currPos = $p6;
    $r11 = self::$FAILED;
    goto seq_21;
  }
  seq_21:
  // filename <- $r11
  if ($r11===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_19;
  }
  // free $p6
  $r2 = true;
  seq_19:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a45($r11);
  }
  // free $r12,$r4,$r13
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseio_here($silence, $boolParams) {
  $key = json_encode([70,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start choice_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "<") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(81); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardDLESSDASH();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3!==self::$FAILED) {
    $this->savedPos = $p1;
    $r3 = $this->a46();
    goto choice_1;
  }
  // start seq_3
  $r5 = $this->input[$this->currPos] ?? '';
  if ($r5 === "<") {
    $r5 = false;
    $this->currPos = $p1;
  } else {
    $r5 = self::$FAILED;
    if (!$silence) { $this->fail(82); }
    $r3 = self::$FAILED;
    goto seq_3;
  }
  $r3 = $this->discardDLESS();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r3!==self::$FAILED) {
    $this->savedPos = $p1;
    $r3 = $this->a47();
  }
  choice_1:
  // op <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_4
  $p7 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r8 = true;
    $r8 = false;
    $this->currPos = $p7;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(83); }
    $r6 = self::$FAILED;
    goto seq_4;
  }
  $r6 = $this->parsehere_end($silence, $boolParams);
  if ($r6===self::$FAILED) {
    $this->currPos = $p7;
    $r6 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  // end <- $r6
  if ($r6===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p7
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a48($r3, $r6);
  }
  // free $r4,$r5,$r8
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsesingle_quoted_part($silence) {
  $key = json_encode([160,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "'") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(84); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $p5 = $this->currPos;
  $r4 = strcspn($this->input, "'", $this->currPos);
  // contents <- $r4
  $this->currPos += $r4;
  $r4 = substr($this->input, $p5, $this->currPos - $p5);
  // free $p5
  if (($this->input[$this->currPos] ?? null) === "'") {
    $r6 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(84); }
    $r6 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a49($r4);
  }
  // free $r3,$r6
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsedouble_quoted_part($silence, $boolParams) {
  $key = json_encode([162,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "\"") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(86); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = [];
  for (;;) {
    // start choice_1
    // start seq_2
    $p6 = $this->currPos;
    $r7 = $this->input[$this->currPos] ?? '';
    if ($r7 === "\\") {
      $r7 = false;
      $this->currPos = $p6;
    } else {
      $r7 = self::$FAILED;
      if (!$silence) { $this->fail(87); }
      $r5 = self::$FAILED;
      goto seq_2;
    }
    $r5 = $this->parsedquoted_escape($silence);
    if ($r5===self::$FAILED) {
      $this->currPos = $p6;
      $r5 = self::$FAILED;
      goto seq_2;
    }
    seq_2:
    if ($r5!==self::$FAILED) {
      goto choice_1;
    }
    // free $p6
    // start seq_3
    $p6 = $this->currPos;
    $r8 = $this->input[$this->currPos] ?? '';
    if ($r8 === "`") {
      $r8 = false;
      $this->currPos = $p6;
    } else {
      $r8 = self::$FAILED;
      if (!$silence) { $this->fail(64); }
      $r5 = self::$FAILED;
      goto seq_3;
    }
    $r5 = $this->parsebackquote_expansion($silence, $boolParams);
    if ($r5===self::$FAILED) {
      $this->currPos = $p6;
      $r5 = self::$FAILED;
      goto seq_3;
    }
    seq_3:
    if ($r5!==self::$FAILED) {
      goto choice_1;
    }
    // free $p6
    // start seq_4
    $p6 = $this->currPos;
    $r9 = $this->input[$this->currPos] ?? '';
    if ($r9 === "\$") {
      $r9 = false;
      $this->currPos = $p6;
    } else {
      $r9 = self::$FAILED;
      if (!$silence) { $this->fail(65); }
      $r5 = self::$FAILED;
      goto seq_4;
    }
    $r5 = $this->parsedollar_expansion($silence, $boolParams);
    if ($r5===self::$FAILED) {
      $this->currPos = $p6;
      $r5 = self::$FAILED;
      goto seq_4;
    }
    seq_4:
    if ($r5!==self::$FAILED) {
      goto choice_1;
    }
    // free $p6
    if (($this->input[$this->currPos] ?? null) === "\\") {
      $r5 = "\\";
      $this->currPos++;
      goto choice_1;
    } else {
      if (!$silence) { $this->fail(88); }
      $r5 = self::$FAILED;
    }
    $p6 = $this->currPos;
    $r5 = strcspn($this->input, "\"\$\\`", $this->currPos);
    if ($r5 > 0) {
      $this->currPos += $r5;
      $r5 = substr($this->input, $p6, $this->currPos - $p6);
    } else {
      $r5 = self::$FAILED;
      if (!$silence) { $this->fail(89); }
      $r5 = self::$FAILED;
    }
    // free $p6
    choice_1:
    if ($r5!==self::$FAILED) {
      $r4[] = $r5;
    } else {
      break;
    }
  }
  // contents <- $r4
  // free $r5
  // free $r7,$r8,$r9
  if (($this->input[$this->currPos] ?? null) === "\"") {
    $r9 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(86); }
    $r9 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a50($r4);
  }
  // free $r3,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsebare_escape_sequence($silence) {
  $key = json_encode([166,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "\\") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(88); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = self::charAt($this->input, $this->currPos);
  // contents <- $r4
  if ($r4 !== '' && !($r4 === "\x0a")) {
    $this->currPos += strlen($r4);
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(90); }
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a51($r4);
  }
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsebackquote_expansion($silence, $boolParams) {
  $key = json_encode([168,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "`") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(91); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = [];
  for (;;) {
    // start choice_1
    // start seq_2
    $p6 = $this->currPos;
    $r7 = $this->input[$this->currPos] ?? '';
    if ($r7 === "\\") {
      $r7 = false;
      $this->currPos = $p6;
    } else {
      $r7 = self::$FAILED;
      if (!$silence) { $this->fail(92); }
      $r5 = self::$FAILED;
      goto seq_2;
    }
    $r5 = $this->parsebackquoted_escape($silence);
    if ($r5===self::$FAILED) {
      $this->currPos = $p6;
      $r5 = self::$FAILED;
      goto seq_2;
    }
    seq_2:
    if ($r5!==self::$FAILED) {
      goto choice_1;
    }
    // free $p6
    // start seq_3
    $p6 = $this->currPos;
    $r8 = $this->input[$this->currPos] ?? '';
    if ($r8 === "\$") {
      $r8 = false;
      $this->currPos = $p6;
    } else {
      $r8 = self::$FAILED;
      if (!$silence) { $this->fail(65); }
      $r5 = self::$FAILED;
      goto seq_3;
    }
    $r5 = $this->parsedollar_expansion($silence, $boolParams);
    if ($r5===self::$FAILED) {
      $this->currPos = $p6;
      $r5 = self::$FAILED;
      goto seq_3;
    }
    seq_3:
    if ($r5!==self::$FAILED) {
      goto choice_1;
    }
    // free $p6
    // start seq_4
    $p6 = $this->currPos;
    $r9 = $this->input[$this->currPos] ?? '';
    if ($r9 === "\\") {
      $r9 = false;
      $this->currPos = $p6;
    } else {
      $r9 = self::$FAILED;
      if (!$silence) { $this->fail(93); }
      $r5 = self::$FAILED;
      goto seq_4;
    }
    $r5 = $this->parsedouble_backquote_expansion($silence, $boolParams);
    if ($r5===self::$FAILED) {
      $this->currPos = $p6;
      $r5 = self::$FAILED;
      goto seq_4;
    }
    seq_4:
    if ($r5!==self::$FAILED) {
      goto choice_1;
    }
    // free $p6
    if (($this->input[$this->currPos] ?? null) === "\$") {
      $r5 = "\$";
      $this->currPos++;
      goto choice_1;
    } else {
      if (!$silence) { $this->fail(94); }
      $r5 = self::$FAILED;
    }
    if (($this->input[$this->currPos] ?? null) === "\\") {
      $r5 = "\\";
      $this->currPos++;
      goto choice_1;
    } else {
      if (!$silence) { $this->fail(88); }
      $r5 = self::$FAILED;
    }
    $p6 = $this->currPos;
    $r5 = strcspn($this->input, "\$\\`", $this->currPos);
    if ($r5 > 0) {
      $this->currPos += $r5;
      $r5 = substr($this->input, $p6, $this->currPos - $p6);
    } else {
      $r5 = self::$FAILED;
      if (!$silence) { $this->fail(95); }
      $r5 = self::$FAILED;
    }
    // free $p6
    choice_1:
    if ($r5!==self::$FAILED) {
      $r4[] = $r5;
    } else {
      break;
    }
  }
  // parts <- $r4
  // free $r5
  // free $r7,$r8,$r9
  if (($this->input[$this->currPos] ?? null) === "`") {
    $r9 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(91); }
    $r9 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a52($r4);
  }
  // free $r3,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsedollar_expansion($silence, $boolParams) {
  $key = json_encode([174,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "\$") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(94); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start choice_1
  // start seq_2
  $p5 = $this->currPos;
  if (strspn($this->input, "!#\$*-0?@", $this->currPos, 1) !== 0) {
    $r6 = true;
    $r6 = false;
    $this->currPos = $p5;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(96); }
    $r4 = self::$FAILED;
    goto seq_2;
  }
  $r4 = $this->parsespecial_parameter($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  // start seq_3
  $p5 = $this->currPos;
  if (strspn($this->input, "123456789", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p5;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(97); }
    $r4 = self::$FAILED;
    goto seq_3;
  }
  $r4 = $this->parseshort_positional_parameter($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  // start seq_4
  $p5 = $this->currPos;
  $r8 = $this->input[$this->currPos] ?? '';
  if ($r8 === "{") {
    $r8 = false;
    $this->currPos = $p5;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(98); }
    $r4 = self::$FAILED;
    goto seq_4;
  }
  $r4 = $this->parsebrace_expansion($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  // start seq_5
  $p5 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "(") {
    $r9 = false;
    $this->currPos = $p5;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(99); }
    $r4 = self::$FAILED;
    goto seq_5;
  }
  $r4 = $this->parsearithmetic_expansion($silence, $boolParams);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  // start seq_6
  $p5 = $this->currPos;
  $r10 = $this->input[$this->currPos] ?? '';
  if ($r10 === "(") {
    $r10 = false;
    $this->currPos = $p5;
  } else {
    $r10 = self::$FAILED;
    if (!$silence) { $this->fail(100); }
    $r4 = self::$FAILED;
    goto seq_6;
  }
  $r4 = $this->parsecommand_expansion($silence, $boolParams);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  // start seq_7
  $p5 = $this->currPos;
  $r11 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r11)) {
    $r11 = false;
    $this->currPos = $p5;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(101); }
    $r4 = self::$FAILED;
    goto seq_7;
  }
  $r4 = $this->parsenamed_parameter($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  // free $p5
  choice_1:
  // contents <- $r4
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a53($r4);
  }
  // free $r3,$r6,$r7,$r8,$r9,$r10,$r11
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseplain_part($silence, $boolParams) {
  $key = json_encode([198,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  $p4 = $this->currPos;
  // start seq_1
  if (/*no_rbrace*/($boolParams & 0x1) !== 0) {
    $r5 = false;
  } else {
    $r5 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_1;
  }
  $r6 = null;
  if (preg_match("/[^\\x09-\\x0d \"\$&-);-<>\\\\`{-}]+/A", $this->input, $r6, 0, $this->currPos)) {
    $this->currPos += strlen($r6[0]);
    $r6 = true;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(102); }
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_1;
  }
  $r3 = true;
  seq_1:
  if ($r3!==self::$FAILED) {
    $r3 = substr($this->input, $p4, $this->currPos - $p4);
    goto choice_1;
  } else {
    $r3 = self::$FAILED;
  }
  // free $r5,$r6
  // free $p4
  $p4 = $this->currPos;
  // start seq_2
  if (!(/*no_rbrace*/($boolParams & 0x1) !== 0)) {
    $r6 = false;
  } else {
    $r6 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r5 = null;
  if (preg_match("/[^\\x09-\\x0d \"\$&-);-<>\\\\`|]+/A", $this->input, $r5, 0, $this->currPos)) {
    $this->currPos += strlen($r5[0]);
    $r5 = true;
  } else {
    $r5 = self::$FAILED;
    if (!$silence) { $this->fail(103); }
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = true;
  seq_2:
  if ($r3!==self::$FAILED) {
    $r3 = substr($this->input, $p4, $this->currPos - $p4);
  } else {
    $r3 = self::$FAILED;
  }
  // free $r6,$r5
  // free $p4
  choice_1:
  // plain <- $r3
  $r2 = $r3;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a54($r3);
  }
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardElse() {
  $key = json_encode([109,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "else", $this->currPos, 4, false) === 0) {
    $r3 = true;
    $this->currPos += 4;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardElif() {
  $key = json_encode([111,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "elif", $this->currPos, 4, false) === 0) {
    $r3 = true;
    $this->currPos += 4;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardDo() {
  $key = json_encode([115,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "do", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardDone() {
  $key = json_encode([117,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "done", $this->currPos, 4, false) === 0) {
    $r3 = true;
    $this->currPos += 4;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardBang() {
  $key = json_encode([133,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "!") {
    $r3 = true;
    $this->currPos++;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardIn() {
  $key = json_encode([135,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "in", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->discardDELIM();
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  // free $r3,$r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardDELIM() {
  $key = json_encode([155,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  $r2 = strspn($this->input, "\x09\x0b\x0c\x0d ", $this->currPos);
  if ($r2 > 0) {
    $this->currPos += $r2;
    goto choice_1;
  } else {
    $r2 = self::$FAILED;
  }
  if ($this->currPos < $this->inputLength) {
    $r2 = true;
  } else {
    $r2 = self::$FAILED;
  }
  if ($r2 === self::$FAILED) {
    $r2 = false;
    goto choice_1;
  } else {
    $r2 = self::$FAILED;
    $this->currPos = $p1;
  }
  if (($this->input[$this->currPos] ?? null) === "\x0a") {
    $r2 = true;
    $r2 = false;
    $this->currPos = $p1;
  } else {
    $r2 = self::$FAILED;
  }
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardseparator() {
  $key = json_encode([81,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "&" || $r4 === ";") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardseparator_op();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardlinebreak();
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // free $r3,$r4
  // start seq_3
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "\x0a") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  $r2 = $this->discardnewline_list();
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecase_item($silence, $boolParams) {
  $key = json_encode([36,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "(") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(19); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardLPAREN();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r3 = null;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(104); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsepattern($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // pattern <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === ")") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(20); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardRPAREN();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_5
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r11 = true;
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r10 = self::$FAILED;
    goto seq_5;
  }
  $r10 = $this->parsecompound_list($silence, $boolParams);
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  // list <- $r10
  if ($r10===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_6
  $p6 = $this->currPos;
  $r13 = $this->input[$this->currPos] ?? '';
  if ($r13 === ";") {
    $r13 = false;
    $this->currPos = $p6;
  } else {
    $r13 = self::$FAILED;
    if (!$silence) { $this->fail(105); }
    $r12 = self::$FAILED;
    goto seq_6;
  }
  $r12 = $this->discardDSEMI();
  if ($r12===self::$FAILED) {
    $this->currPos = $p6;
    $r12 = self::$FAILED;
    goto seq_6;
  }
  seq_6:
  if ($r12===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $this->discardlinebreak();
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a55($r5, $r10);
    goto choice_1;
  }
  // free $r3,$r4,$r7,$r8,$r9,$r11,$r12,$r13
  // start seq_7
  // start seq_8
  $r12 = $this->input[$this->currPos] ?? '';
  if ($r12 === "(") {
    $r12 = false;
    $this->currPos = $p1;
  } else {
    $r12 = self::$FAILED;
    if (!$silence) { $this->fail(19); }
    $r13 = self::$FAILED;
    goto seq_8;
  }
  $r13 = $this->discardLPAREN();
  if ($r13===self::$FAILED) {
    $this->currPos = $p1;
    $r13 = self::$FAILED;
    goto seq_8;
  }
  seq_8:
  if ($r13===self::$FAILED) {
    $r13 = null;
  }
  // start seq_9
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r9 = true;
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(104); }
    $r11 = self::$FAILED;
    goto seq_9;
  }
  $r11 = $this->parsepattern($silence, $boolParams);
  if ($r11===self::$FAILED) {
    $this->currPos = $p6;
    $r11 = self::$FAILED;
    goto seq_9;
  }
  seq_9:
  // pattern <- $r11
  if ($r11===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_7;
  }
  // free $p6
  // start seq_10
  $p6 = $this->currPos;
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === ")") {
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(20); }
    $r8 = self::$FAILED;
    goto seq_10;
  }
  $r8 = $this->discardRPAREN();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_10;
  }
  seq_10:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_7;
  }
  // free $p6
  $this->discardlinebreak();
  // start seq_11
  $p6 = $this->currPos;
  $r3 = $this->input[$this->currPos] ?? '';
  if ($r3 === ";") {
    $r3 = false;
    $this->currPos = $p6;
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(105); }
    $r4 = self::$FAILED;
    goto seq_11;
  }
  $r4 = $this->discardDSEMI();
  if ($r4===self::$FAILED) {
    $this->currPos = $p6;
    $r4 = self::$FAILED;
    goto seq_11;
  }
  seq_11:
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_7;
  }
  // free $p6
  $this->discardlinebreak();
  $r2 = true;
  seq_7:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a56($r11);
  }
  // free $r13,$r12,$r9,$r8,$r7,$r4,$r3
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecase_item_ns($silence, $boolParams) {
  $key = json_encode([34,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "(") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(19); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardLPAREN();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3===self::$FAILED) {
    $r3 = null;
  }
  // start seq_3
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(104); }
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->parsepattern($silence, $boolParams);
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  // pattern <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_4
  $p6 = $this->currPos;
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === ")") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(20); }
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardRPAREN();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  // start seq_5
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0b\x0c\x0d &);|", $this->currPos, 1) !== 0) {
    $r11 = true;
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    if (!$silence) { $this->fail(39); }
    $r10 = self::$FAILED;
    goto seq_5;
  }
  $r10 = $this->parsecompound_list($silence, $boolParams);
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  // list <- $r10
  if ($r10===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a55($r5, $r10);
    goto choice_1;
  }
  // free $r3,$r4,$r7,$r8,$r9,$r11
  // start seq_6
  // start seq_7
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "(") {
    $r9 = false;
    $this->currPos = $p1;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(19); }
    $r11 = self::$FAILED;
    goto seq_7;
  }
  $r11 = $this->discardLPAREN();
  if ($r11===self::$FAILED) {
    $this->currPos = $p1;
    $r11 = self::$FAILED;
    goto seq_7;
  }
  seq_7:
  if ($r11===self::$FAILED) {
    $r11 = null;
  }
  // start seq_8
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r7 = true;
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(104); }
    $r8 = self::$FAILED;
    goto seq_8;
  }
  $r8 = $this->parsepattern($silence, $boolParams);
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_8;
  }
  seq_8:
  // pattern <- $r8
  if ($r8===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_6;
  }
  // free $p6
  // start seq_9
  $p6 = $this->currPos;
  $r3 = $this->input[$this->currPos] ?? '';
  if ($r3 === ")") {
    $r3 = false;
    $this->currPos = $p6;
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(20); }
    $r4 = self::$FAILED;
    goto seq_9;
  }
  $r4 = $this->discardRPAREN();
  if ($r4===self::$FAILED) {
    $this->currPos = $p6;
    $r4 = self::$FAILED;
    goto seq_9;
  }
  seq_9:
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_6;
  }
  // free $p6
  $this->discardlinebreak();
  $r2 = true;
  seq_6:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a57($r8);
  }
  // free $r11,$r9,$r7,$r4,$r3
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardLESSAND() {
  $key = json_encode([95,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "<&", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardLESSGREAT() {
  $key = json_encode([99,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "<>", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardLESS() {
  $key = json_encode([143,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "<") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardDLESS();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3 === self::$FAILED) {
    $r3 = false;
  } else {
    $r3 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $p6 = $this->currPos;
  // start seq_3
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === "<") {
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->discardLESSAND();
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r5 === self::$FAILED) {
    $r5 = false;
  } else {
    $r5 = self::$FAILED;
    $this->currPos = $p6;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $p6 = $this->currPos;
  // start seq_4
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === "<") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardLESSGREAT();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8 === self::$FAILED) {
    $r8 = false;
  } else {
    $r8 = self::$FAILED;
    $this->currPos = $p6;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $p6 = $this->currPos;
  // start seq_5
  $r11 = $this->input[$this->currPos] ?? '';
  if ($r11 === "<") {
    $r11 = false;
    $this->currPos = $p6;
  } else {
    $r11 = self::$FAILED;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  $r10 = $this->discardDLESSDASH();
  if ($r10===self::$FAILED) {
    $this->currPos = $p6;
    $r10 = self::$FAILED;
    goto seq_5;
  }
  seq_5:
  if ($r10 === self::$FAILED) {
    $r10 = false;
  } else {
    $r10 = self::$FAILED;
    $this->currPos = $p6;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  if (($this->input[$this->currPos] ?? null) === "<") {
    $r12 = true;
    $this->currPos++;
  } else {
    $r12 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3,$r4,$r5,$r7,$r8,$r9,$r10,$r11,$r12
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardGREATAND() {
  $key = json_encode([97,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, ">&", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardDGREAT() {
  $key = json_encode([93,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, ">>", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardCLOBBER() {
  $key = json_encode([103,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, ">|", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardGREAT() {
  $key = json_encode([145,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === ">") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardDGREAT();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3 === self::$FAILED) {
    $r3 = false;
  } else {
    $r3 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $p6 = $this->currPos;
  // start seq_3
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === ">") {
    $r7 = false;
    $this->currPos = $p6;
  } else {
    $r7 = self::$FAILED;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = $this->discardGREATAND();
  if ($r5===self::$FAILED) {
    $this->currPos = $p6;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r5 === self::$FAILED) {
    $r5 = false;
  } else {
    $r5 = self::$FAILED;
    $this->currPos = $p6;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  $p6 = $this->currPos;
  // start seq_4
  $r9 = $this->input[$this->currPos] ?? '';
  if ($r9 === ">") {
    $r9 = false;
    $this->currPos = $p6;
  } else {
    $r9 = self::$FAILED;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  $r8 = $this->discardCLOBBER();
  if ($r8===self::$FAILED) {
    $this->currPos = $p6;
    $r8 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r8 === self::$FAILED) {
    $r8 = false;
  } else {
    $r8 = self::$FAILED;
    $this->currPos = $p6;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p6
  if (($this->input[$this->currPos] ?? null) === ">") {
    $r10 = true;
    $this->currPos++;
  } else {
    $r10 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3,$r4,$r5,$r7,$r8,$r9,$r10
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardDLESSDASH() {
  $key = json_encode([101,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "<<-", $this->currPos, 3, false) === 0) {
    $r3 = true;
    $this->currPos += 3;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardDLESS() {
  $key = json_encode([91,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "<<", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r2 = true;
  seq_1:
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsehere_end($silence, $boolParams) {
  $key = json_encode([72,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $p2 = $this->currPos;
  // start seq_1
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r3 = self::$FAILED;
    goto seq_1;
  }
  $r3 = $this->discardWORD($boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  if ($r3!==self::$FAILED) {
    $r3 = substr($this->input, $p2, $this->currPos - $p2);
  } else {
    $r3 = self::$FAILED;
  }
  // free $p2
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r3

  );
  return $r3;
}
private function parsedquoted_escape($silence) {
  $key = json_encode([164,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "\\") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(88); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // contents <- $r4
  if (strspn($this->input, "\x0a\"\$\\`", $this->currPos, 1) !== 0) {
    $r4 = $this->input[$this->currPos];
    $this->currPos++;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(106); }
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a58($r4);
  }
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsebackquoted_escape($silence) {
  $key = json_encode([170,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "\\") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(88); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r4 = $this->input[$this->currPos] ?? '';
  // contents <- $r4
  if ($r4 === "\$" || $r4 === "\\") {
    $this->currPos++;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(107); }
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a59($r4);
  }
  // free $r3
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsedouble_backquote_expansion($silence, $boolParams) {
  $key = json_encode([172,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "\\`", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    if (!$silence) { $this->fail(108); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start choice_1
  // start seq_2
  $p5 = $this->currPos;
  $r6 = $this->input[$this->currPos] ?? '';
  if ($r6 === "\\") {
    $r6 = false;
    $this->currPos = $p5;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(92); }
    $r4 = self::$FAILED;
    goto seq_2;
  }
  $r4 = $this->parsebackquoted_escape($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  // start seq_3
  $p5 = $this->currPos;
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === "\$") {
    $r7 = false;
    $this->currPos = $p5;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(65); }
    $r4 = self::$FAILED;
    goto seq_3;
  }
  $r4 = $this->parsedollar_expansion($silence, $boolParams);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  if (($this->input[$this->currPos] ?? null) === "\$") {
    $r4 = "\$";
    $this->currPos++;
    goto choice_1;
  } else {
    if (!$silence) { $this->fail(94); }
    $r4 = self::$FAILED;
  }
  // start seq_4
  $p5 = $this->currPos;
  if (($this->input[$this->currPos] ?? null) === "\\") {
    $r8 = "\\";
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(88); }
    $r8 = self::$FAILED;
    $r4 = self::$FAILED;
    goto seq_4;
  }
  $p10 = $this->currPos;
  if (($this->input[$this->currPos] ?? null) === "`") {
    $r9 = true;
  } else {
    $r9 = self::$FAILED;
  }
  if ($r9 === self::$FAILED) {
    $r9 = false;
  } else {
    $r9 = self::$FAILED;
    $this->currPos = $p10;
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_4;
  }
  // free $p10
  $r4 = [$r8,$r9];
  seq_4:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $r8,$r9
  // free $p5
  $p5 = $this->currPos;
  $r4 = strcspn($this->input, "\$\\`", $this->currPos);
  if ($r4 > 0) {
    $this->currPos += $r4;
    $r4 = substr($this->input, $p5, $this->currPos - $p5);
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(95); }
    $r4 = self::$FAILED;
  }
  // free $p5
  choice_1:
  // parts <- $r4
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "\\`", $this->currPos, 2, false) === 0) {
    $r9 = true;
    $this->currPos += 2;
  } else {
    if (!$silence) { $this->fail(108); }
    $r9 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a60($r4);
  }
  // free $r3,$r6,$r7,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsespecial_parameter($silence) {
  $key = json_encode([176,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // contents <- $r3
  if (strspn($this->input, "!#\$*-0?@", $this->currPos, 1) !== 0) {
    $r3 = $this->input[$this->currPos];
    $this->currPos++;
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(109); }
  }
  $r2 = $r3;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a61($r3);
  }
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseshort_positional_parameter($silence) {
  $key = json_encode([178,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // contents <- $r3
  if (strspn($this->input, "123456789", $this->currPos, 1) !== 0) {
    $r3 = $this->input[$this->currPos];
    $this->currPos++;
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(110); }
  }
  $r2 = $r3;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a62($r3);
  }
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsebrace_expansion($silence) {
  $key = json_encode([180,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "{") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(111); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start choice_1
  // start seq_2
  $p5 = $this->currPos;
  $r6 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[!#-\$*\\-0-9?-Z_a-z]/A", $r6)) {
    $r6 = false;
    $this->currPos = $p5;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(112); }
    $r4 = self::$FAILED;
    goto seq_2;
  }
  $r4 = $this->parsebinary_expansion($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  // start seq_3
  $p5 = $this->currPos;
  $r7 = $this->input[$this->currPos] ?? '';
  if ($r7 === "#") {
    $r7 = false;
    $this->currPos = $p5;
  } else {
    $r7 = self::$FAILED;
    if (!$silence) { $this->fail(113); }
    $r4 = self::$FAILED;
    goto seq_3;
  }
  $r4 = $this->parsestring_length($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  if ($r4!==self::$FAILED) {
    goto choice_1;
  }
  // free $p5
  // start seq_4
  $p5 = $this->currPos;
  $r8 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[!#-\$*\\-0-9?-Z_a-z]/A", $r8)) {
    $r8 = false;
    $this->currPos = $p5;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(114); }
    $r4 = self::$FAILED;
    goto seq_4;
  }
  $r4 = $this->parsebraced_parameter_expansion($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  // free $p5
  choice_1:
  // contents <- $r4
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  if (($this->input[$this->currPos] ?? null) === "}") {
    $r9 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(115); }
    $r9 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a53($r4);
  }
  // free $r3,$r6,$r7,$r8,$r9
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsearithmetic_expansion($silence, $boolParams) {
  $key = json_encode([186,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "((", $this->currPos, 2, false) === 0) {
    $r3 = true;
    $this->currPos += 2;
  } else {
    if (!$silence) { $this->fail(116); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  $r4 = [];
  for (;;) {
    // start seq_2
    $p6 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
      $r7 = true;
      $r7 = false;
      $this->currPos = $p6;
    } else {
      $r7 = self::$FAILED;
      if (!$silence) { $this->fail(23); }
      $r5 = self::$FAILED;
      goto seq_2;
    }
    $r5 = $this->parseWORD($silence, $boolParams);
    if ($r5===self::$FAILED) {
      $this->currPos = $p6;
      $r5 = self::$FAILED;
      goto seq_2;
    }
    seq_2:
    if ($r5!==self::$FAILED) {
      $r4[] = $r5;
    } else {
      break;
    }
    // free $p6
  }
  if (count($r4) === 0) {
    $r4 = self::$FAILED;
  }
  // words <- $r4
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $r5
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "))", $this->currPos, 2, false) === 0) {
    $r5 = true;
    $this->currPos += 2;
  } else {
    if (!$silence) { $this->fail(117); }
    $r5 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a63($r4);
  }
  // free $r3,$r5
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsecommand_expansion($silence, $boolParams) {
  $key = json_encode([188,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "(") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(118); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_2
  $p5 = $this->currPos;
  if (strcspn($this->input, "\x0a&);|", $this->currPos, 1) !== 0) {
    $r6 = true;
    $r6 = false;
    $this->currPos = $p5;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(1); }
    $r4 = self::$FAILED;
    goto seq_2;
  }
  $r4 = $this->parsecomplete_command($silence, $boolParams);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // command <- $r4
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p5
  if (($this->input[$this->currPos] ?? null) === ")") {
    $r7 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(119); }
    $r7 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a64($r4);
  }
  // free $r3,$r6,$r7
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsenamed_parameter($silence) {
  $key = json_encode([196,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $r4 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r4)) {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(18); }
    $r3 = self::$FAILED;
    goto seq_1;
  }
  $r3 = $this->parseNAME($silence);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  // name <- $r3
  $r2 = $r3;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a65($r3);
  }
  // free $r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsepattern($silence, $boolParams) {
  $key = json_encode([38,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parseWORD($silence, $boolParams);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // first <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r5 = [];
  for (;;) {
    // start seq_3
    $p7 = $this->currPos;
    // start seq_4
    $r9 = $this->input[$this->currPos] ?? '';
    if ($r9 === "|") {
      $r9 = false;
      $this->currPos = $p7;
    } else {
      $r9 = self::$FAILED;
      if (!$silence) { $this->fail(12); }
      $r8 = self::$FAILED;
      goto seq_4;
    }
    $r8 = $this->parsePIPE($silence);
    if ($r8===self::$FAILED) {
      $this->currPos = $p7;
      $r8 = self::$FAILED;
      goto seq_4;
    }
    seq_4:
    if ($r8===self::$FAILED) {
      $r6 = self::$FAILED;
      goto seq_3;
    }
    // start seq_5
    $p11 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
      $r12 = true;
      $r12 = false;
      $this->currPos = $p11;
    } else {
      $r12 = self::$FAILED;
      if (!$silence) { $this->fail(23); }
      $r10 = self::$FAILED;
      goto seq_5;
    }
    $r10 = $this->parseWORD($silence, $boolParams);
    if ($r10===self::$FAILED) {
      $this->currPos = $p11;
      $r10 = self::$FAILED;
      goto seq_5;
    }
    seq_5:
    if ($r10===self::$FAILED) {
      $this->currPos = $p7;
      $r6 = self::$FAILED;
      goto seq_3;
    }
    // free $p11
    $r6 = [$r8,$r10];
    seq_3:
    if ($r6!==self::$FAILED) {
      $r5[] = $r6;
    } else {
      break;
    }
    // free $r8,$r9,$r10,$r12
    // free $p7
  }
  // rest <- $r5
  // free $r6
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a66($r3, $r5);
  }
  // free $r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function discardWORD($boolParams) {
  $key = json_encode([157,$this->currPos,$boolParams & 0x1]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $r3 = [];
  for (;;) {
    // start seq_2
    $p5 = $this->currPos;
    if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
      $r6 = true;
      $r6 = false;
      $this->currPos = $p5;
    } else {
      $r6 = self::$FAILED;
      $r4 = self::$FAILED;
      goto seq_2;
    }
    $r4 = $this->parseword_part(true, $boolParams);
    if ($r4===self::$FAILED) {
      $this->currPos = $p5;
      $r4 = self::$FAILED;
      goto seq_2;
    }
    seq_2:
    if ($r4!==self::$FAILED) {
      $r3[] = $r4;
    } else {
      break;
    }
    // free $p5
  }
  if (count($r3) === 0) {
    $r3 = self::$FAILED;
  }
  // parts <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $r4
  $this->discardOWS();
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a18($r3);
  }
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsebinary_expansion($silence) {
  $key = json_encode([182,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[!#-\$*\\-0-9?-Z_a-z]/A", $r4)) {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(120); }
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->parseparameter($silence);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // parameter <- $r3
  if ($r3===self::$FAILED) {
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start choice_1
  $p6 = $this->currPos;
  // start seq_3
  $p7 = $this->currPos;
  if (($this->input[$this->currPos] ?? null) === ":") {
    $r8 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(121); }
    $r8 = self::$FAILED;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  if (strspn($this->input, "+-=?", $this->currPos, 1) !== 0) {
    $r9 = true;
    $this->currPos++;
  } else {
    $r9 = self::$FAILED;
    if (!$silence) { $this->fail(122); }
    $this->currPos = $p7;
    $r5 = self::$FAILED;
    goto seq_3;
  }
  $r5 = true;
  seq_3:
  if ($r5!==self::$FAILED) {
    $r5 = substr($this->input, $p6, $this->currPos - $p6);
    goto choice_1;
  } else {
    $r5 = self::$FAILED;
  }
  // free $r8,$r9
  // free $p7
  // free $p6
  $p6 = $this->currPos;
  // start choice_2
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "%%", $this->currPos, 2, false) === 0) {
    $r5 = true;
    $this->currPos += 2;
    goto choice_2;
  } else {
    if (!$silence) { $this->fail(123); }
    $r5 = self::$FAILED;
  }
  if ($this->currPos >= $this->inputLength ? false : substr_compare($this->input, "##", $this->currPos, 2, false) === 0) {
    $r5 = true;
    $this->currPos += 2;
    goto choice_2;
  } else {
    if (!$silence) { $this->fail(124); }
    $r5 = self::$FAILED;
  }
  if (strspn($this->input, "#%+-=?", $this->currPos, 1) !== 0) {
    $r5 = true;
    $this->currPos++;
  } else {
    $r5 = self::$FAILED;
    if (!$silence) { $this->fail(125); }
  }
  choice_2:
  if ($r5!==self::$FAILED) {
    $r5 = substr($this->input, $p6, $this->currPos - $p6);
  } else {
    $r5 = self::$FAILED;
  }
  // free $p6
  choice_1:
  // operator <- $r5
  if ($r5===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $this->discardOWS();
  // start seq_4
  $p6 = $this->currPos;
  if (strcspn($this->input, "\x09\x0a\x0b\x0c\x0d &();<>|", $this->currPos, 1) !== 0) {
    $r8 = true;
    $r8 = false;
    $this->currPos = $p6;
  } else {
    $r8 = self::$FAILED;
    if (!$silence) { $this->fail(23); }
    $r9 = self::$FAILED;
    goto seq_4;
  }
  $r9 = $this->parseWORD($silence, 0x1);
  if ($r9===self::$FAILED) {
    $this->currPos = $p6;
    $r9 = self::$FAILED;
    goto seq_4;
  }
  seq_4:
  if ($r9===self::$FAILED) {
    $r9 = null;
  }
  // free $p6
  // word <- $r9
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a67($r3, $r5, $r9);
  }
  // free $r4,$r8
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsestring_length($silence) {
  $key = json_encode([184,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  if (($this->input[$this->currPos] ?? null) === "#") {
    $r3 = true;
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(126); }
    $r3 = self::$FAILED;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // start seq_2
  $p5 = $this->currPos;
  $r6 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[!#-\$*\\-0-9?-Z_a-z]/A", $r6)) {
    $r6 = false;
    $this->currPos = $p5;
  } else {
    $r6 = self::$FAILED;
    if (!$silence) { $this->fail(120); }
    $r4 = self::$FAILED;
    goto seq_2;
  }
  $r4 = $this->parseparameter($silence);
  if ($r4===self::$FAILED) {
    $this->currPos = $p5;
    $r4 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  // parameter <- $r4
  if ($r4===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  // free $p5
  $r2 = true;
  seq_1:
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a68($r4);
  }
  // free $r3,$r6
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsebraced_parameter_expansion($silence) {
  $key = json_encode([190,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $r4 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[!#-\$*\\-0-9?-Z_a-z]/A", $r4)) {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(120); }
    $r3 = self::$FAILED;
    goto seq_1;
  }
  $r3 = $this->parseparameter($silence);
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  // parameter <- $r3
  $r2 = $r3;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a69($r3);
  }
  // free $r4
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parsePIPE($silence) {
  $key = json_encode([146,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  // start seq_2
  $r4 = $this->input[$this->currPos] ?? '';
  if ($r4 === "|") {
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  $r3 = $this->discardOR_IF();
  if ($r3===self::$FAILED) {
    $this->currPos = $p1;
    $r3 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r3 === self::$FAILED) {
    $r3 = false;
  } else {
    $r3 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  if (($this->input[$this->currPos] ?? null) === "|") {
    $r5 = "|";
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(127); }
    $r5 = self::$FAILED;
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r6 = $this->parseOWS($silence);
  $r2 = [$r3,$r5,$r6];
  seq_1:
  // free $r3,$r4,$r5,$r6
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseparameter($silence) {
  $key = json_encode([192,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start choice_1
  // start seq_1
  if (strspn($this->input, "!#\$*-0?@", $this->currPos, 1) !== 0) {
    $r3 = true;
    $r3 = false;
    $this->currPos = $p1;
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(96); }
    $r2 = self::$FAILED;
    goto seq_1;
  }
  $r2 = $this->parsespecial_parameter($silence);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_1;
  }
  seq_1:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_2
  if (strspn($this->input, "0123456789", $this->currPos, 1) !== 0) {
    $r4 = true;
    $r4 = false;
    $this->currPos = $p1;
  } else {
    $r4 = self::$FAILED;
    if (!$silence) { $this->fail(128); }
    $r2 = self::$FAILED;
    goto seq_2;
  }
  $r2 = $this->parselong_positional_parameter($silence);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_2;
  }
  seq_2:
  if ($r2!==self::$FAILED) {
    goto choice_1;
  }
  // start seq_3
  $r5 = $this->input[$this->currPos] ?? '';
  if (preg_match("/[A-Z_a-z]/A", $r5)) {
    $r5 = false;
    $this->currPos = $p1;
  } else {
    $r5 = self::$FAILED;
    if (!$silence) { $this->fail(101); }
    $r2 = self::$FAILED;
    goto seq_3;
  }
  $r2 = $this->parsenamed_parameter($silence);
  if ($r2===self::$FAILED) {
    $this->currPos = $p1;
    $r2 = self::$FAILED;
    goto seq_3;
  }
  seq_3:
  choice_1:
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parseOWS($silence) {
  $key = json_encode([152,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  // start seq_1
  $r3 = strspn($this->input, "\x09\x0b\x0c\x0d ", $this->currPos);
  $this->currPos += $r3;
  $r3 = substr($this->input, $this->currPos - $r3, $r3);
  $r3 = mb_str_split($r3, 1, "utf-8");
  // start seq_2
  $p5 = $this->currPos;
  if (($this->input[$this->currPos] ?? null) === "#") {
    $r6 = "#";
    $this->currPos++;
  } else {
    if (!$silence) { $this->fail(126); }
    $r6 = self::$FAILED;
    $r4 = self::$FAILED;
    goto seq_2;
  }
  $r7 = strcspn($this->input, "\x0a", $this->currPos);
  $this->currPos += $r7;
  $r7 = substr($this->input, $this->currPos - $r7, $r7);
  $r7 = mb_str_split($r7, 1, "utf-8");
  $r4 = [$r6,$r7];
  seq_2:
  if ($r4===self::$FAILED) {
    $r4 = null;
  }
  // free $r6,$r7
  // free $p5
  $r2 = [$r3,$r4];
  seq_1:
  // free $r3,$r4
  // free $p1
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}
private function parselong_positional_parameter($silence) {
  $key = json_encode([194,$this->currPos]);
  $cached = $this->cache[$key] ?? null;
  if ($cached) {
    $this->currPos = $cached->nextPos;

    return $cached->result;
  }
  $p1 = $this->currPos;
  $p4 = $this->currPos;
  $r3 = strspn($this->input, "0123456789", $this->currPos);
  // parameter <- $r3
  if ($r3 > 0) {
    $this->currPos += $r3;
    $r3 = substr($this->input, $p4, $this->currPos - $p4);
  } else {
    $r3 = self::$FAILED;
    if (!$silence) { $this->fail(57); }
    $r3 = self::$FAILED;
  }
  // free $p4
  $r2 = $r3;
  if ($r2!==self::$FAILED) {
    $this->savedPos = $p1;
    $r2 = $this->a70($r3);
  }
  $this->cache[$key] = new PEGParserCacheEntry(
    $this->currPos,
    $r2

  );
  return $r2;
}

	public function parse( $input, $options = [] ) {
		$this->initInternal( $input, $options );
		$startRule = $options['startRule'] ?? '(DEFAULT)';
		$result = null;

		if ( !empty( $options['stream'] ) ) {
			switch ( $startRule ) {
				
			default:
				throw new \Wikimedia\WikiPEG\InternalError( "Can't stream rule $startRule." );
			}
		} else {
			switch ( $startRule ) {
				case '(DEFAULT)':
case "program":
  $result = $this->parseprogram(false);
  break;
			default:
				throw new \Wikimedia\WikiPEG\InternalError( "Can't start parsing from rule $startRule." );
			}
		}

		if ( $result !== self::$FAILED && $this->currPos === $this->inputLength ) {
			return $result;
		} else {
			if ( $result !== self::$FAILED && $this->currPos < $this->inputLength ) {
				$this->fail( 0 );
			}
			throw $this->buildParseException();
		}
	}
}

